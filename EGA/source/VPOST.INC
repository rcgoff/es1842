	SUBTTL	VPOST.INC
	PAGE

;----- POST

	ASSUME	CS:CODE,DS:ABS0
	ORG	0H
	DB	055H				; SIGNATURE
	DB	0AAH				;  BYTES
	DB	020H				; LENGTH INDICATOR

;----- NOTE : DO NOT USE THE SIGNATURE BYTES AS A PRESENCE TEST

;	PLANAR VIDEO SWITCH SETTINGS

;	0 0 - UNUSED
;	0 1 - 40 X 25 COLOR
;	1 0 - 80 X 25 COLOR
;	1 1 - 80 X 25 MONOCHROME
; NOTE : 0 0 MUST BE SET WHEN THIS ADAPTER IS INSTALLED.

;	VIDEO ADAPTER SWITCH SETTINGS

;	0 0 0 0 - MONOC PRIMARY, EGA COLOR, 40X25
;	0 0 0 1 - MONOC PRIMARY, EGA COLOR, 80X25
;	0 0 1 0 - MONOC PRIMARY, EGA HI RES EMULATE (SAME AS 0001)
;	0 0 1 1 - MONOC PRIMARY, EGA HI RES ENHANCED
;	0 1 0 0 - COLOR 40 PRIMARY, EGA MONOCHROME
;	0 1 0 1 - COLOR 80 PRIMARY, EGA MONOCHROME

;	0 1 1 0 - MONOC SECONDARY, EGA COLOR, 40X25
;	0 1 1 1 - MONOC SECONDARY, EGA COLOR, 80X25
;	1 0 0 0 - MONOC SECONDARY, EGA HI RES EMULATE (SAME AS 0111)
;	1 0 0 1 - MONOC SECONDARY, EGA HI RES ENHANCED
;	1 0 1 0 - COLOR 40 SECONDARY, EGA MONOCHROME
;	1 0 1 1 - COLOR 80 SECONDARY, EGA MONOCHROME

;	1 1 0 0 - RESERVED
;	1 1 0 1 - RESERVED
;	1 1 1 0 - RESERVED
;	1 1 1 1 - RESERVED

;----- SETUP ROUTINE FOR THIS MODULE

VIDEO_SETUP	PROC	FAR
	JMP	SHORT	L1
	DB	'2400'
	DB	'6277356 (C)COPYRIGHT IBM 1984'




	DB	'9/13/84'


;----- SET UP VIDEO VECTORS

L1:
	MOV	DH,3
	MOV	DL,INPUT_STATUS
	IN	AL,DX
	MOV	DL,INPUT_STATUS_B
	IN	AL,DX
	MOV	DL,ATTR_WRITE
	MOV	AL,0
	OUT	DX,AL

	SRLOAD	DS,0
	CLI
	MOV	WORD PTR VIDEO,OFFSET COMBO_VIDEO
	MOV	WORD PTR VIDEO+2, CS
	MOV	WORD PTR PLANAR_VIDEO,0F065H
	MOV	WORD PTR PLANAR_VIDEO+2,0F000H
	MOV	WORD PTR SAVE_PTR,OFFSET SAVE_TBL
	MOV	WORD PTR SAVE_PTR+2, CS
	MOV	WORD PTR EXT_PTR, OFFSET INT_1F_1
	MOV	WORD PTR EXT_PTR+2, CS
	MOV	WORD PTR GRX_SET, OFFSET CGDDOT
	MOV	WORD PTR GRX_SET+2, CS
	STI
	
;----- POST FOR COMBO VIDEO CARD

	MOV	INFO,00000100B
	CALL	RD_SWS
	MOV	INFO_3,BL
	CALL	F_BTS
	OR	INFO_3,AL
	MOV	BL,INFO_3
	CALL	MK_ENV
	JMP	POST
SKIP:
	RET
VIDEO_SETUP	ENDP


POR_1	PROC	NEAR
	OUT	DX,AL
	PUSH	AX
	POP	AX
	IN	AL,DX
	AND	AL,010H
	SHR	AL,1
	RET
POR_1	ENDP

;----- READ THE SWITCH SETTINGS ON THE CARD

RD_SWS	PROC	NEAR
	ASSUME	DS:ABS0
	MOV	DH,3
	MOV	DL,MISC_OUTPUT
	MOV	AL,1
	OUT	DX,AL

;----- COULD BE 0,4,8,C

	MOV	AL,0DH
	CALL	POR_1
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	MOV	BL,AL

	MOV	AL,9
	CALL	POR_1
	SHR	AL,1
	SHR	AL,1
	OR	BL,AL

	MOV	AL,5
	CALL	POR_1
	SHR	AL,1
	OR	BL,AL

	MOV	AL,1
	CALL	POR_1
	OR	BL,AL

	AND	BL,0FH
	RET
RD_SWS	ENDP

;----- OBTAIN THE FEATURE BITS FROM DAUGHTER CARD

F_BTS	PROC	NEAR
	MOV	DH,3
	MOV	DL,0BAH
	MOV	AL,1
	OUT	DX,AL
	MOV	DL,0DAH
	OUT	DX,AL
	MOV	DL,IN_STAT_0
	IN	AL,DX				; READ FEATURE BITS
	AND	AL,060H
	SHR	AL,1
	MOV	BL,AL
	MOV	DL,0BAH
	MOV	AL,2
	OUT	DX,AL
	MOV	DL,0DAH
	OUT	DX,AL
	MOV	DL,IN_STAT_0
	IN	AL,DX				; READ FEATURE BITS
	AND	AL,060H
	SHL	AL,1
	OR	AL,BL
	RET
F_BTS	ENDP

;----- ESTABLISH THE VIDEO ENVIRONMENT, KEYED OFF OF THE SWITCHES

MK_ENV	PROC	NEAR
	ASSUME	DS:ABS0
	SUB	BH,BH
	AND	BL,0FH
	SAL	BX,1
	PUSH	DX
	MOV	DH,3
	MOV	AH,DH
	POP	DX
	AND	AH,1
	INC	AH
	NOT	AH
	JMP	WORD PTR CS:[BX + OFFSET T5]

SAVE_TBL	LABEL	DWORD
	DW	OFFSET	VIDEO_PARMS		; PARMS
	DW	0C000H				; PARMS
	DW	0				; PAL SAVE AREA
	DW	0				; PAL SAVE AREA
	DW	0				; ALPHA TABLES
	DW	0				; ALPHA TABLES
	DW	0				; GRAPHICS TABLES
	DW	0				; GRAPHICS TABLES

	DW	0
	DW	0
	DW	0
	DW	0
	DW	0
	DW	0
	
T5	LABEL	WORD
	DW	OFFSET PST_0
	DW	OFFSET PST_1
	DW	OFFSET PST_2
	DW	OFFSET PST_3
	DW	OFFSET PST_4
	DW	OFFSET PST_5
	DW	OFFSET PST_6
	DW	OFFSET PST_7

	DW	OFFSET PST_8
	DW	OFFSET PST_9
	DW	OFFSET PST_A
	DW	OFFSET PST_B
	DW	OFFSET PST_OUT
	DW	OFFSET PST_OUT
	DW	OFFSET PST_OUT
	DW	OFFSET PST_OUT

ENV_X	PROC	NEAR				; SET 40X25 COLOR ALPHA
	AND	EQUIP_LOW,0CFH
	OR	EQUIP_LOW,010H
	MOV	AX,1H
	INT	10H
	RET
ENV_X	ENDP

ENV_0	PROC	NEAR				; SET 80X25 COLOR ALPHA
	AND	EQUIP_LOW,0CFH
	OR	EQUIP_LOW,020H
	MOV	AX,03H
	INT	10H
	RET
ENV_0	ENDP

ENV_3	PROC	NEAR				; SET MONOCHROME ALPHA
	OR	EQUIP_LOW,030H
	MOV	AX,07H
	INT	10H
	RET
ENV_3	ENDP


PST_0:
	AND	INFO,AH
	CALL	ENV_X
	CALL	ENV_3
	RET
PST_1:
PST_2:
	AND	INFO,AH
	CALL	ENV_0
	CALL	ENV_3
	RET
PST_3:
	AND	INFO,AH
	CALL	ENV_0
	CALL	ENV_3
	RET
PST_4:
	MOV	DH,3
	MOV	DL,MISC_OUTPUT
	MOV	AL,0
	OUT	DX,AL
	NOT	AH
	OR	INFO,AH
	CALL	ENV_3
	CALL	ENV_X
	RET
PST_5:
	MOV	DH,3
	MOV	DL,MISC_OUTPUT
	MOV	AL,0
	OUT	DX,AL
	NOT	AH
	OR	INFO,AH
	CALL	ENV_3
	CALL	ENV_0
	RET
PST_6:
	AND	INFO,AH
	CALL	ENV_3
	CALL	ENV_X
	RET
PST_7:
PST_8:
	AND	INFO,AH
	CALL	ENV_3
	CALL	ENV_0
	RET
PST_9:
	AND	INFO,AH
	CALL	ENV_3
	CALL	ENV_0
	RET
PST_A:
	MOV	DH,3
	MOV	DL,MISC_OUTPUT
	MOV	AL,0
	OUT	DX,AL
	NOT	AH
	OR	INFO,AH
	CALL	ENV_X
	CALL	ENV_3
	RET
PST_B:
	MOV	DH,3
	MOV	DL,MISC_OUTPUT
	MOV	AL,0
	OUT	DX,AL
	NOT	AH
	OR	INFO,AH
	CALL	ENV_0
	CALL	ENV_3
PST_OUT:
	RET
MK_ENV	ENDP

;------------------------------------------------------------------------
; THIS ROUTINE TESTS THE CRT CARD INTERNAL DATA BUS AND IN A LIMITED	:
; WAY TESTS THE CRTC VIDEO CHIP BY WRITING/READING FROM CURSOR REGISTER :
; CARRY IS SET IF AN ERROR IS FOUND					:
;									:
; REGISTERS BX,SI,ES,DS ARE PRESERVED.					:
; REGISTERS AX,CX,DX ARE MODIFYED.					:
;------------------------------------------------------------------------
CD_PRESENCE_TST PROC	NEAR
	PUSH	BX			; SAVE BX
	MOV	BX,07FH			; INITIAL WORD PATTERN BYTE
	MOV	DI,BX
	PUSH	AX			; SAVE PORT ADDRESS
	CALL	RD_CURSOR		;
	MOV	SI,AX			; SAVE ORIGINAL VALUE
	POP	AX			; RECOVER PORT ADDRESS
	PUSH	AX			; SAVE PORT ADDRESS
	CALL	WR_CURSOR		; WRITE CURSOR
	POP	AX			; RECOVER PORT ADDRESS
	PUSH	AX			; SAVE PORT ADDRESS
	CALL	RD_CURSOR		; READ IT BACK
	CMP	AX,DI			; SAME?
	POP	AX
	JNZ	NOT_PRESENT		; EXIT IF NOT EQUAL
	JMP	TST_EX
NOT_PRESENT:
	XOR	AX,AX			; SET NOT PRESENT
	POP	BX
	RET
TST_EX:
	MOV	AX,1			; SET PRESENT ON EXIT
	POP	BX			; RESTORE BX
	RET
CD_PRESENCE_TST ENDP

;------------------------------------------------------------------------
; MODULE NAME  RD_CURSOR						:
;  READ CURSOR POSITION [ADDRESS] (FROM CRTC) TO  AX			:
;									:
; REGISTER AX IS MODIFIED.						:
;------------------------------------------------------------------------
RD_CURSOR	PROC	NEAR
	PUSH	DX			; SAVE REGS USED
	MOV	DX,AX
	MOV	AL,C_CRSR_LOC_HGH
	OUT	DX,AL
	INC	DX
	IN	AL,DX
					; RETURN WITH CURSOR POS IN AX
					; RESTORE REGS USED
	POP	DX
	RET
RD_CURSOR	ENDP

;------------------------------------------------------------------------
; MODULE NAME  WR_CURSOR						:
;  WRITE CURSOR POSITION [ADDRESS] (TO CRTC) WITH CONTENTS OF AX	:
;									:
; ALL REGISTERS PRESERVED						:
;------------------------------------------------------------------------
WR_CURSOR	PROC NEAR
					; SAVE REGS USED
	PUSH	AX
	PUSH	DX
	MOV	DX,AX
	MOV	AH,C_CRSR_LOC_HGH	; CURSOR LOCATION HIGH INDEX
	MOV	AL,07FH			; TEST VALUE
	CALL	OUT_DX
					; RETURN WITH CURSOR POS IN AX
					; RESTORE REGS USED
	POP	DX
	POP	AX
	RET
WR_CURSOR	ENDP

POST:
;--------------------------------------------------------
;	INITIALIZE AND START CRT CONTROLLER (6845)	:
;	ON COLOR GRAPHICS AND MONOCHROME CARDS		:
;	TEST VIDEO READ/WRITE STORAGE.			:
; DESCRIPTION						:
;	RESET THE VIDEO ENABLE SIGNAL.			:
;	SELECT ALPHANUMERIC MODE, 40 * 25, B & W.	:
;	READ/WRITE DATA PATTERNS TO STG. CHECK STG	:
;	ADDRESSABILITY.					:
;--------------------------------------------------------
	ASSUME	DS:ABS0,ES:ABS0
	CALL	DDS
	TEST	INFO,2
	JNZ	COLOR_PRESENCE_TST
	MOV	AX,03B4H
	CALL	CD_PRESENCE_TST
	CMP	AX,1
	JE	CONT1
	JMP	POD14
CONT1:
	MOV	AH,30H			; MONOCHROME CARD INSTALLED
	JMP	SHORT OVER
COLOR_PRESENCE_TST:
	MOV	AX,03D4H
	CALL	CD_PRESENCE_TST
	CMP	AX,1
	JE	CONT2
	JMP	POD14
CONT2:
	MOV	AH,20H			; COLOR GRAPHICS CARD INSTALLED
OVER:
	PUSH	AX			; RESAVE VALUE
	MOV	BX,0B000H		; BEG VIDEO RAM ADDR B/W CD
	MOV	DX,3B8H			; MODE CONTROL B/W
	MOV	CX,4096			; RAM BYTE CNT FOR B/W CD
	MOV	AL,1			; SET MODE FOR BW CARD
	CMP	AH,30H			; B/W VIDEO CARD ATTACHED?
	JE	E9			; GO TEST VIDEO STG
	MOV	BH,0B8H			; BEG VIDEO RAM ADDR COLOR CD
	MOV	DL,0D8H			; MODE CONTROL COLOR
	MOV	CH,40H			; RAM BYTE CNT FOR COLOR CD
	DEC	AL			; SET MODE TO 0 FOR COLOR CD
E9:					; TEST_VIDEO_STG:
	OUT	DX,AL			; DISABLE VIDEO FOR COLOR CD

	MOV	BP,DS:RESET_FLAG	; POD INITIALIZED BY KBD RESET

	CMP	BP,1234H		; POD INITIATED BY KBD RESET?
	MOV	ES,BX			; POINT ES TO VIDEO RAM STG
	JE	E10			; YES - SKIP VIDEO RAM TEST
	MOV	DS,BX			; POINT DS TO VIDEO RAM STG
	ASSUME	DS:NOTHING,ES:NOTHING
	CALL	STGTST_CNT		; GO TEST VIDEO R/W STG
	JNE	E17			; R/W STG FAILURE - BEEP SPK
;----------------------------------------------------------------
;	SETUP VIDEO DATA ON SCREEN FOR VIDEO LINE TEST.		:
; DESCRIPTION							:
;	ENABLE VIDEO SIGNAL AND SET MODE.			:
;	DISPLAY A HORIZONTAL BAR ON SCREEN.			:
;----------------------------------------------------------------
E10:
	POP	AX			; GET VIDEO SENSE SWS (AH)
	PUSH	AX			; SAVE IT
	MOV	AX,7020H		; WRT BLANKS IN REVERSE VIDEO
	SUB	DI,DI			; SETUP STARTING LOC
	MOV	CX,40			; NO. OF BLANKS TO DISPLAY
	REP	STOSW			; WRITE VIDEO STORAGE
;--------------------------------------------------------
;	CRT INTERFACE LINES TEST			:
; DESCRIPTION						:
;	SENSE ON/OFF TRANSITION OF THE VIDEO ENABLE	:
;	AND HORIZONTAL SYNC LINES.			:
;--------------------------------------------------------
	POP	AX			; GET VIDEO SENSE SW INFO
	PUSH	AX			; SAVE IT
	CMP	AH,30H			; B/W CARD ATTACHED?
	MOV	DX,03BAH		; SETUP ADDR OF B/W STATUS PORT
	JE	E11			; YES - GO TEST LINES
	MOV	DL,0DAH			; COLOR CARD IS ATTACHED
E11:					; LINE_TST:
	MOV	AH,8
E12:					; OFLOOP_CNT
	SUB	CX,CX
E13:
	IN	AL,DX			; READ CRT STATUS PORT
	AND	AL,AH			; CHECK VIDEO/HORZ LINE
	JNZ	E14			; ITS ON - CHECK IF IT GOES OFF
	LOOP	E13			; LOOP TILL ON OR TIMEOUT
	JMP	SHORT E17		; GO PRINT ERROR MSG
E14:
	SUB	CX,CX
E15:
	IN	AL,DX			; READ CRT STATUS PORT
	AND	AL,AH			; CHECK VIDEO/HORZ LINE
	JZ	E16			; ITS ON - CHECK NEXT LINE
	LOOP	E15			; LOOP IF OFF TILL IT GOES ON
E17:					;  CRT_ERR
	MOV	DX,102H
	CALL	ERR_BEEP		; GO BEEP SPEAKER
	JMP	SHORT E18
E16:					; NXT_LINE
	MOV	CL,3			; GET NEXT BIT TO CHECK
	SHR	AH,CL
	JNZ	E12			; GO CHECK HORIZONTAL LINE
E18:					;  DISPLAY_CURSOR:
	POP	AX			; GET VIDEO SENSE SWS (AH)
	JMP	SHORT	POD14

;------------------------------------------------------------------------
;	THIS SUBROUTINE PERFORMS A READ/WRITE STORAGE TEST ON		:
;	A 16K BLOCK OF STORAGE.						:
; ENTRY REQUIREMENTS:							:
;	ES = ADDRESS OF STORAGE SEGMENT BEING TESTED			:
;	DS = ADDRESS OF STORAGE SEGMENT BEING TESTED			:
;	WHEN ENTERING AT STGTST_CNT, CX MUST BE LOADED WITH		:
;	THE BYTE COUNT.							:
; EXIT PARAMETERS:							:
;	ZERO FLAG = 0 IF STORAGE ERROR (DATA COMPARE OR PARITY CHECK.	:
;	       AL = 0 DENOTES A PARITY CHECK. ELSE AL=XOR'ED BIT        :
;		      PATTERN OF THE EXPECTED DATA PATTERN VS THE	:
;		      ACTUAL DATA READ.					:
;	AX,BX,CX,DX,DI, AND SI ARE ALL DESTROYED.			:
;------------------------------------------------------------------------
STGTST	PROC	NEAR
	MOV	CX,4000H		; SETUP CNT TO TEST A 16K BLK
STGTST_CNT:
	CLD				; SET DIR FLAG TO INCREMENT
	MOV	BX,CX			; SAVE CNT (4K FOR VIDEO OR 16K)
	MOV	AX,0AAAAH		; GET DATA PATTERN TO WRITE
	MOV	DX,0FF55H		; SETUP OTHER DATA PATTERNS TO USE
	SUB	DI,DI			; DI = OFFSET 0 RELATIVE TO ES REG
	REP	STOSB			; WRITE STORAGE LOCATIONS
C3:					;  STG01
	DEC	DI			; POINT TO LAST BYTE JUST WRITTEN
	STD				; SET DIR FLAG TO GO BACKWARDS
C4:
	MOV	SI,DI
	MOV	CX,BX			; SETUP BYTE CNT
C5:					; INNER TEST LOOP
	LODSB				; LOAD OLD TEST BYTE [SI]+
	XOR	AL,AH			; DATA READ AS EXPECTED ?
	JNE	C7			;  NO - GO TO ERROR ROUTINE
	MOV	AL,DL			; GET NEXT DATA PATTERN TO WRITE
	STOSB				; WRITE INTO LOCATION JUST READ
	LOOP	C5			;  DECREMENT COUNT AND LOOP CX

	AND	AH,AH			; ENDING 0 PATTERN WRITTEN TO STG?
	JZ	C6X			; YES - RETURN TO CALLER WITH AL=0
	MOV	AH,AL			; SETUP NEW VALUE FOR COMPARE
	XCHG	DH,DL			; MOVE NEXT DATA PATTERN TO DL
	AND	AH,AH			; READING ZERO PATTERN THIS PASS ?
	JNZ	C6			; CONTINUE TEST SEQUENCE TILL 0
	MOV	DL,AH			;  ELSE SET 0 FOR END READ PATTERN
	JMP	C3			;  AND MAKE FINAL BACKWARDS PASS
C6:
	CLD				; SET DIR FLAG TO GO FORWARD
	INC	DI			; SET POINTER TO BEG LOCATION
	JZ	C4			; READ/WRITE FORWARD IN STG
	DEC	DI			; ADJUST POINTER
	JMP	C3			; READ/WRITE BACKWARD IN STG
C6X:
	MOV	AL,000H			; AL=0 DATA COMPARE OK
C7:
	CLD				; SET DIRECTION FLAG BACK TO INC
	RET
STGTST	ENDP

;--------------------------------------------------------
;		EGA CRT ATTACHMENT TEST			:
;							:
; 1. INIT CRT TO 40X25 - BW  ****SET TO MODE****	:
; 2. CHECK FOR VERTICAL AND VIDEO ENABLES, AND CHECK	:
;    TIMING OF SAME					:
; 3. CHECK VERTICAL INTERRUPT				:
; 4. CHECK RED, BLUE, GREEN, AND INTENSIFY DOTS		:
; 5. INIT TO 40X25 - COLOR/MONO ****SET TO MODE****	:
;--------------------------------------------------------

;----- NOMINAL TIME IS B286H FOR 60 HZ.
;----- NOMINAL TIME IS A2FEH FOR 50 HZ.

MAX_VERT_COLOR	EQU	0A0ACH			; MAX TIME FOR VERT/VERT
						;  (NOMINAL + 10%)
MIN_VERT_COLOR	EQU	0C460H			; MIN TIME FOR VERT/VERT
						;  (NOMINAL - 10%)
CENAB_PER_FRAME EQU	200			; NUM OF ENABLES PER FRAME
MAX_VERT_MONO	EQU	08D99H			; MAX TIME FOR VERT/VERT
						;  (NOMINAL + 10%)
MIN_VERT_MONO	EQU	0B862H			; MIN TIME FOR VERT /VERT
						; (NOMINAL - 10%)
EENAB_PER_FRAME EQU	350			; ENHANCED ENABLES PER FRAME
MENAB_PER_FRAME EQU	350			; NUM OF ENABLES PER FRAME

TIM_CTL		EQU	043H			; 8253 TIMER CONTROL PORT
TIMER0		EQU	040H			; 8253 TIMER/CNTER 0 PORT

POD14	PROC	NEAR
	SUB	SP,0AH				; RESERVE 5 WORDS ON STACK
	MOV	BP,SP				; INIT SCRATCH PAD POINTER

	ASSUME	DS:ABS0,ES:ABS0
	CALL	DDS
	MOV	AL,00110000B			; SET TIMER 0 TO MODE 0

	OUT	TIM_CTL,AL
	MOV	AL,00H
	OUT	TIMER0,AL			; SEND FIRST BYTE TO TIMER
	TEST	INFO,2
	JZ	COLOR_EGA_V
	CALL	ENV_3				; SET UP IN MONOCHROME
	MOV	WORD PTR[BP][2],MENAB_PER_FRAME ; NUM. OF FRAMES FOR MONO
	MOV	WORD PTR[BP][4],MAX_VERT_MONO	; MAX TIME FOR VERT/VERT
	MOV	WORD PTR[BP][6],MIN_VERT_MONO	; MIN TIME FOR VERT/VERT
	MOV	DL,CRTC_ADDR_B			; MONO CRTC REG
	MOV	AH,C_HRZ_DSP			; HORIZ. TOTAL DIPLAY
	MOV	AL,27H				;  TO 40 COL
	CALL	OUT_DX
	MOV	DL,INPUT_STATUS_B		; 3BA
	JMP	SHORT	COMMON
COLOR_EGA_V:
	CALL	ENV_X				; SET UP IN 40X25 COLOR
	CALL	BRST_DET			; ENHANCED MODE
	JNC	COLOR_V				; NO,40X25
	MOV	DL,CRTC_ADDR			; BRST MODE ONLY!
	MOV	AH,1				; HRZ DSP END
	MOV	AL,20				; MODIFY FOR TEST ONLY
	CALL	OUT_DX
	MOV	WORD PTR[BP][2],EENAB_PER_FRAME ; NUM. OF FRAMES FOR COLOR
	JMP	BRST_COLOR_V
COLOR_V:

	MOV	WORD PTR[BP][2],CENAB_PER_FRAME ; NUM. OF FRAMES FOR COLOR
BRST_COLOR_V:
	MOV	WORD PTR[BP][4],MAX_VERT_COLOR	; MAX TIME FOR VERT/VERT
	MOV	WORD PTR[BP][6],MIN_VERT_COLOR	; MIN TIME FOR VERT /VERT
	MOV	DL,INPUT_STATUS			; SET ADDRESSING TO VIDEO
						;  ATTR STATUS
COMMON:
	MOV	AX,0500H			; SET TO VIDEO PAGE 0
	INT	10H
	SUB	CX,CX

;----- LOOK FOR VERTICAL

POD14_1:
	IN	AL,DX				; GET STATUS
	TEST	AL,00001000B			; VERTICAL THERE YET?
	JNE	POD14_2				; CONTINUE IF IT IS
	LOOP	POD14_1				; KEEP LOOKING TILL COUNT
	MOV	BL,00				;  EXHAUSTED
	JMP	POD14_ERR			; NO VERTICAL

;----- GOT VERTICAL - START TIMER

POD14_2:
	MOV	AL,0
	OUT	TIMER0,AL			; SEND 2ND BYTE TO TIMER TO
						; START IT
	SUB	BX,BX				; INIT. ENABLE COUNTER
;----- WAIT FOR VERTICAL TO GO AWAY
	XOR	CX,CX
POD14_25:
	IN	AL,DX				; GET STATUS
	TEST	AL,00001000B			; VERTICAL STILL THERE
	JZ	POD14_3				; CONTINUE IF IT'S GONE
	LOOP	POD14_25			; KEEP LOOKING TILL COUNT
	MOV	BL,01H				;  EXHAUSTED
	JMP	POD14_ERR			; VERTICAL STUCK ON

;----- NOW START LOOKING FOR ENABLE TRANSITIONS

POD14_3:
	SUB	CX,CX
POD14_4:
	IN	AL,DX				; GET STATUS
	TEST	AL,00000001B			; ENABLE ON YET?
	JE	POD14_5				; GO ON IF IT IS
	TEST	AL,00001000B			; VERTICAL ON AGAIN?
	JNE	POD14_75			; CONTINUE IF IT IS
	LOOP	POD14_4				; KEEP LOOKING IF NOT
	MOV	BL,02H
	JMP	POD14_ERR			; ENABLE STUCK OFF
POD14_4A:
	MOV	BL,03H
	JMP	POD14_ERR			; VERTICAL STUCK ON
POD14_4B:
	MOV	BL,04H
	JMP	POD14_ERR			; ENABLE STUCK ON

;----- MAKE SURE VERTICAL WENT OFF WITH ENABLE GOING ON

POD14_5:
	TEST	AL,00001000B			; VERTICAL OFF?
	JNZ	POD14_4A			; GO ON IF IT IS
;----- NOW WAIT FOR ENABLE TO GO OFF		;  (ERROR IF NOT)
POD14_6:
	IN	AL,DX				; GET STATUS
	TEST	AL,00000001B			; ENABLE OFF YET?
	LOOPE	POD14_6				; KEEP LOOKING IF NOT
	JCXZ	POD14_4B			;  YET LOW
;----- ENABLE HAS TOGGLED, BUMP COUNTER AND TEST FOR NEXT VERTICAL
POD14_7:
	INC	BX				; BUMP ENABLE COUNTER
	JZ POD14_75				; IF COUNTER WRAPS,
						;  SOMETHING IS WRONG
	TEST	AL,00001000B			; DID ENABLE GO LOW
						;  BECAUSE OF VERTICAL
	JZ	POD14_3				; IF NOT, LOOK FOR ANOTHER
						;  ENABLE TOGGLE
;----- HAVE HAD COMPLETE VERTICAL-VERTICAL CYCLE, NOW TEST RESULTS
POD14_75:
	MOV	AL,00				; LATCH TIMER0
	OUT	TIM_CTL,AL
	CMP	BX,WORD PTR[BP][2]		; NUMBER OF ENABLES BETWEEN
						;  VERTICALS O.K.?
	JE	POD14_8
	MOV	BL,05H
	JMP	SHORT POD14_ERR
POD14_8:
	IN	AL,TIMER0			; GET TIMER VALUE LOW
	MOV	AH,AL				; SAVE IT
	NOP
	IN	AL,TIMER0			; GET TIMER HIGH
	XCHG	AH,AL
	NOP
	NOP
	CMP	AX,WORD PTR[BP][4]		; MAXIMUM VERTICAL TIMING
	JGE	POD14_9
	MOV	BL,06H
	JMP	SHORT POD14_ERR
POD14_9:
	CMP	AX,WORD PTR[BP][6]		; MINIMUM VERTICAL TIMING
	JLE	POD14_10
	MOV	BL,07H
	JMP	SHORT POD14_ERR

;----- SEE IF RED, GREEN, BLUE AND INTENSIFY DOTS WORK

;----- FIRST, SET A LINE OF REVERSE VIDEO, INTENSIFIED BLANKS INTO BUFFER
POD14_10:
	MOV	AX,09DBH			; WRITE CHARS, BLANKS
	MOV	BX,000FH			; PAGE 0, REVERSE VIDEO,
						;  HIGH INTENSITY
	MOV	CX,80				; 80 CHARACTERS
	INT	10H
	IN	AL,DX
	PUSH	DX				; SAVE INPUT STATUS
	MOV	DL,ATTR_WRITE			; ATTRIBUTE ADDRESSS
	MOV	AH,0FH				; PALETTE REG 'F'
	MOV	AL,03FH				; TEST VALUE
	CALL	OUT_DX				; VIDEO STATUS MUX
	MOV	AX,0FH				; START WITH BLUE DOTS
	POP	DX
POD14_13:
	PUSH	AX				; SAVE
	PUSH	DX				; SAVE INPUT STATUS
	MOV	DL,ATTR_WRITE			; ATTRIBUTE ADDRESSS
	MOV	AH,32H				; COLOR PLANE ENABLE
	CALL	OUT_DX				; VIDEO STATUS MUX
	POP	DX				; RECOVER INPUT STATUS
	POP	AX
	SUB	CX,CX
;----- SEE IF DOT COMES ON
POD14_14:
	IN	AL,DX				; GET STATUS
	TEST	AL,00110000B			; DOT THERE?
	JNZ	POD14_15			; LOOK FOR DOT TO TURN OFF
	LOOP	POD14_14			; CONTINUE TEST FOR DOT ON
	MOV	BL,10H
	OR	BL,AH				; OR IN DOT BEING TESTED
	JMP	POD14_ERR			; DOT NOT COMING ON
;----- SEE IF DOT GOES OFF
POD14_15:
	SUB	CX,CX
POD14_16:
	IN	AL,DX				; GET STATUS
	TEST	AL,00110000B			; IS DOT STILL ON?
	JE	POD14_17			; GO ON IF DOT OFF
	LOOP	POD14_16			; ELSE, KEEP WAITING FOR
						;  DOT TO GO OFF
	MOV	BL,20H
	OR	BL,AH				; OR IN DOT BEING TESTED
	JMP	SHORT POD14_ERR

;----- ADJUST TO POINT TO NEXT DOT

POD14_17:
	INC	AH
	CMP	AH,030H				; ALL 3 DOTS DONE?
	JE	POD14_18			; GO END
	OR	AH,0FH				; MAKE 0F,1F,2F
	MOV	AL,AH
	JMP	POD14_13			; GO LOOK FOR ANOTHER DOT
POD14_ERR:
	MOV	CX,6
	MOV	DX,0103H			; ONE LONG AND THREE SHORT
	CALL	ERR_BEEP
	ADD	SP,0AH				; BALANCE STACK
	MOV	AL,00110110B			; RE-INIT TIMER 0
	OUT	TIM_CTL,AL
	SUB	AL,AL
	OUT	TIMER0,AL
	NOP
	NOP
	OUT	TIMER0,AL
	MOV	BP,1
	JMP	SKIP
	ASSUME	DS:ABS0
POD14_18:
	CALL	DDS
	MOV	AX,0500H			; SET TO VIDEO PAGE 0
	INT	10H
	MOV	AL,00110110B			; RE-INIT TIMER 0
	OUT	TIM_CTL,AL
	SUB	AL,AL
	OUT	TIMER0,AL
	NOP
	NOP
	OUT	TIMER0,AL
	ADD	SP,0AH				; REMOVE SCRATCH PAD
	MOV	BP,0				; MAKE BP NON ZERO
POD14	ENDP

;----- TEST STORAGE

MEM_TEST:
	PUSH	DS
	CALL	DDS
	ASSUME	DS:ABS0
	TEST	INFO,2
	JZ	D_COLOR_M
	OR	EQUIP_LOW,030H
	MOV	AX,0FH
	OR	INFO,060H
	MOV	AX,0FH
	JMP	SHORT D_OUT_M
D_COLOR_M:
	AND	EQUIP_LOW,0CFH
	OR	EQUIP_LOW,020H
	MOV	AX,0EH				; INTERNAL COLOR MODE
D_OUT_M:					; TEST IN COLOR
	INT	10H
	SUB	SP,6				; RESERVE 3 WORDS ON STACK
	MOV	BP,SP				; SET BP
	MOV	AX,0A000H			; PUT BUFFER ADDRESS IN AX
	ASSUME	DS:NOTHING,ES:NOTHING
	MOV	DS,AX				; SET UP SEG REGS TO POINT
	MOV	ES,AX				; TO BUFFER AREA
	MOV	WORD PTR[BP][2],0		; INITIALIZE
	MOV	WORD PTR[BP][4],0		; INITIALIZE
	MOV	DH,3
	MOV	DL,SEQ_ADDR
	MOV	AX,0201H
	CALL	OUT_DX
	MOV	DL,GRAPH_ADDR			; ADDRESS READ MAP SELECT
	MOV	AX,0400H
	CALL	OUT_DX
	PUSH	DX
	MOV	DL,ATTR_READ			; SET UP ATTRIBUTE
	IN	AL,DX
	MOV	DL,ATTR_WRITE			; ATTRIBUTE WRITE ADDRESS
	MOV	AX,3200H
	CALL	OUT_DX
	CALL	HOW_BIG				; GO FIND AMOUNT OF MEMORY
	CMP	AH,0
	JZ	AA1
	JMP	EGA_MEM_ERROR
AA1:
	CALL	MEMORY_OK			; GO TEST IT
	CMP	AH,0
	JZ	AA2
	JMP	EGA_MEM_ERROR
AA2:
	POP	DX
	MOV	DL,SEQ_ADDR
	MOV	AX,0202H
	CALL	OUT_DX
	MOV	DL,GRAPH_ADDR			; ADDRESS OF READ MAP
	MOV	AX,0401H
	CALL	OUT_DX
	PUSH	DX
	MOV	DL,ATTR_READ			; SET UP ATTRIBUTE
	IN	AL,DX
	MOV	DL,ATTR_WRITE			; ATTRIBUTE WRITE ADDRESS
	MOV	AX,3200H
	CALL	OUT_DX
	MOV	WORD PTR [BP][4],0		; INITIALIZE
	CALL	HOW_BIG				; GO FIND AMOUNT OF MEMORY
	CMP	AH,0
	JZ	AA3
	JMP	EGA_MEM_ERROR
AA3:
	CALL	MEMORY_OK			; GO TEST IT
	CMP	AH,0
	JZ	AA4
	JMP	EGA_MEM_ERROR
AA4:
	POP	DX
	MOV	DL,SEQ_ADDR
	MOV	AX,0204H
	CALL	OUT_DX
	PUSH	DX
	MOV	DL,GRAPH_ADDR			; ADDRESS OF READ MAP
	MOV	AX,0402H
	CALL	OUT_DX
	MOV	DL,ATTR_READ			; SET UP ATTRIBUTE
	IN	AL,DX
	MOV	DL,ATTR_WRITE			; ATTRIBUTE WRITE ADDRESS
	MOV	AX,3200H
	CALL	OUT_DX
	MOV	WORD PTR[BP][4],0		; INITIALIZE
	CALL	HOW_BIG				; GO FIND AMOUNT OF MEMORY
	CMP	AH,0
	JZ	AA5
	JMP	EGA_MEM_ERROR
AA5:
	CALL	MEMORY_OK			; GO TEST IT
	CMP	AH,0
	JZ	AA6
	JMP	EGA_MEM_ERROR
AA6:
	POP	DX
	MOV	DL,SEQ_ADDR
	MOV	AX,0208H
	CALL	OUT_DX
	MOV	DL,GRAPH_ADDR			; ADDRESS OF READ MAP
	MOV	AX,0403H
	CALL	OUT_DX
	PUSH	DX
	MOV	DL,ATTR_READ			; SET UP ATTRIBUTE
	IN	AL,DX
	MOV	DL,ATTR_WRITE			; ATTRIBUTE WRITE ADDRESS
	MOV	AX,3200H
	CALL	OUT_DX
	MOV	WORD PTR[BP][4],0		; INITIALIZE
	CALL	HOW_BIG				; GO FIND AMOUNT OF MEMORY
	CMP	AH,0
	JNZ	EGA_MEM_ERROR
	CALL	MEMORY_OK			; GO TEST IT
	CMP	AH,0
	JNZ	EGA_MEM_ERROR
	PUSH	BP				; SAVE SCRATCH PAD POINTER
	MOV	BP,0				; RESET BP FOR XT
EGA_MEM_EXIT:
	POP	SI				; RESTORE
	POP	DX
	CALL	DDS				; SET DATA SEGMENT
	ASSUME	DS:ABS0
	MOV	BX,WORD PTR SS:[SI][2]		; GET EGA MEMORY SIZE
	MOV	CL,06H				; DIVIDE BY 64 TO GET
	SHR	BX,CL				;  NUMBER OF 64KB BLOCKS
	DEC	BX
	MOV	CL,05H
	SHL	BX,CL
	AND	BL,01100000B			; ISOLATE BITS 5 AND 6

	AND	INFO,10011111B

	OR	INFO,BL

	OR	INFO,00000100B			; 04H  SET 3XX ACTIVE
	MOV	BL,INFO_3
	CALL	MK_ENV
	ADD	SP,6				; RESTORE STACK
	POP	DS
	JMP	SKIP				; GO TO END
EGA_MEM_ERROR:
	MOV	DX,0103H			; ONE LONG AND THREE SHORT
	CALL	ERR_BEEP
	PUSH	BP				; SAVE SCRATCH PAD POINTER
	MOV	BP,1				; INDICATE ERROR FOR XT
	JMP	EGA_MEM_EXIT

;----- THIS ROUTINE FINDS AMOUNT OF MEMORY GOOD

MEMORY_OK	PROC	NEAR
	MOV	BX,0A000H			; SET PTR. TO BUFFER SEG
	MOV	DS,BX				; SET SEG. REG.
	MOV	ES,BX
	MOV	AX,WORD PTR[BP][4]		; SET COUNT FOR 32K WORDS
	MOV	CH,AL				; SET AMOUNT OF BUFFER
	SUB	CL,CL				; TO BE TESTED
	SHL	CX,1				; MULTIPLY BY TWO
	CALL	PODSTG
	CMP	AH,0				; TEST FOR ERROR
	JNZ	MEMORY_OK_ERR			; IF ERROR GO PRINT IT
MEMORY_OK_EX:
	MOV	AX,WORD PTR[BP][4]		; AMOUNT OF MEMORY FOUND
	ADD	WORD PTR[BP][2],AX		; AMOUNT OF MEMORY GOOD
	MOV	AX,0
MEMORY_OK_ERR:
	RET
MEMORY_OK	ENDP

;----------------------------------------------------------------
; THIS ROUTINE PERFORMS A READ/WRITE TEST ON A BLOCK OF STORAGE :
; (MAX SIZE = 32KW).  IF "WARM START", FILL BLOCK WITH 0000 AND :
; RETURN.							:
; ON ENTRY:							:
;   ES = ADDRESS OF STORAGE TO BE TESTED			:
;   DS = ADDRESS OF STORAGE TO BE TESTED			:
;   CX = WORD COUNT OF STORAGE BLOCK TO BE TESTED		:
;	(MAX. = 8000H (32K WORDS))				:
; ON EXIT:							:
;   ZERO FLAG = OFF IF STORAGE ERROR				:
; AX,BX,CX,DX,DI,SI ARE ALL DESTROYED.				:
;----------------------------------------------------------------
PODSTG	PROC	NEAR
	PUSH	BP
	CLD					; SET DIR TO INCREMENT
	SUB	DI,DI				; SET DI=0000 REL TO START
						;  OF SEGMENT
	SUB	AX,AX				; INITIAL DATA PATTERN FOR
						;  00-FF TEST
	CALL	DDS
	ASSUME	DS:ABS0
	MOV	BX,DS:RESET_FLAG		; WARM START?
	CMP	BX,1234H
	MOV	DX,ES
	MOV	DS,DX				; RESTORE DS
	JE	PODSTG_5			; GO DO FILL WITH 0000
						;  IF WARM START
	CMP	BX,4321H			; DCP WARM START?
	JE	PODSTG_5			; DO FILL IF SO
PODSTG_1:
	MOV	[DI],AL				; WRITE TEST DATA
	MOV	AL,[DI]				; GET IT BACK
	XOR	AL,AH				; COMPARE TO EXPECTED
	JNZ	PODSTG_ERRO			; ERROR EXIT IF MISCOMPARE
	INC	AH				; FORM NEW DATA PATTERN
	MOV	AL,AH
	JNZ	PODSTG_1			; LOOP TILL ALL 256 DATA
						;  PATTERNS DONE
	MOV	BP,CX				; SAVE WORD COUNT
	MOV	AX,0AA55H			; LOAD DATA PATTERN
	MOV	BX,AX
	MOV	DX,055AAH			; LOAD OTHER DATA PATTERN
	REP	STOSW				; FILL WORDS FROM LOW TO
						;  HIGH WITH AAAA
	DEC	DI				; POINT TO LAST WORD
	DEC	DI				;  WRITTEN
	STD					; SET DIR FLAG TO GO DOWN
	MOV	SI,DI				; SET INDEX REGS. EQUAL
	MOV	CX,BP				; RECOVER WORD COUNT
PODSTG_2:					; GO FROM HIGH TO LOW
	LODSW					; GET WORD FROM MEMORY
	XOR	AX,BX				; EQUAL WHAT S/B THERE?
	JNZ	PODSTG_ERRO			; GO ERROR EX IT IF NOT
	MOV	AX,DX				; GET 55 DATA PATTERN AND
	STOSW					;  STORE IN LOC JUST READ
	LOOP	PODSTG_2			; LOOP TILL ALL BYTES DONE
	MOV	CX,BP				; RECOVER WORD COUNT
	CLD					; BACK TO INCREMENT
	INC	SI				; ADJUST PTRS
	INC	SI
	MOV	DI,SI
PODSTG_3:					; LOW TO HIGH DOING WORDS
	LODSW					; GET A WORD
	XOR	AX,DX				; SHOULD COMPARE TO DX
	JNZ	PODSTG_ERRO			; GO ERROR IF NOT
	STOSW					; WRITE 0000 BACK TO LOC
						;  JUST READ
	LOOP	PODSTG_3			; LOOP TILL DONE

	STD					; BACK TO DECREMENT
	DEC	SI				; ADJUST POINTER DOWN TO
						;  LAST WORD WRITTEN
	DEC	SI
	MOV	CX,BP				; GET WORD COUNT
PODSTG_4:
	LODSW					; GET WORD
	OR	AX,AX				; = TO 0000
	JNZ	PODSTG_ERRO			; ERROR IF NOT
	LOOP	PODSTG_4			; LOOP TILL DONE
	JMP	SHORT PODSTG_ERR2
PODSTG_ERRO:
	MOV	CX,AX				; SAVE BITS IN ERROR
	XOR	AH,AH
	OR	CH,CH				; HIGH BYTE ERROR?
	JZ	PODSTG_ERR1
	MOV	AH,1				; SET HIGH BYTE ERROR
PODSTG_ERR1:
	OR	CL,CL				; LOW BYTE ERROR?
	JZ	PODSTG_ERR2
	ADD	AH,2
PODSTG_ERR2:
	POP	BP
	CLD					; SET DIR FLAG BACK TO INC
	RET					; RETURN TO CALLER
PODSTG_5:					; SIMPLE FILL WITH 0000 ON
						;  WARM-START
	PUSH	AX				; SAVE
	PUSH	DX				; SAVE VALUE
	MOV	DH,3
	MOV	DL,SEQ_ADDR			; SEQ_ADDR  REGISTER
	MOV	AX,020FH
	CALL	OUT_DX				; DO IT
	POP	DX				; RESTORE
	POP	AX				; RESTORE
	REP	STOSW
	CALL	DDS
	ASSUME	DS:ABS0
	MOV	DS:RESET_FLAG,BX
	MOV	DS,DX				; RESTORE DS
	JMP	PODSTG_ERR2			; AND EXIT
PODSTG	ENDP

;----- DETERMINE SIZE OF BUFFER

HOW_BIG		PROC NEAR
	MOV	DX,DS				; SET PNTR TO BUFFER LOC
	SUB	BX,BX				; BASIC COUNT OF 00K
FILL_LOOP:
	MOV	ES,DX				; SET SEG. REG
	SUB	DI ,DI
	MOV	AX,0AA55H			; TEST PATTERN
	MOV	CX,AX
	MOV	ES:[DI],AX			; SEND TO MEMORY
	MOV	AL,0FH				; PUT SOMETHING IN AL
	MOV	AX,ES:[DI]			; GET PATTERN FROM MEMORY
	XOR	AX,CX				; COMPARE PATTERNS
	JNZ	HOW_BIG_END			; GO END IF NO COMPARE
	MOV	CX,2000H			; SET COUNT FOR 8K WORDS
	REP	STOSW				; FILL 8K WORDS
	ADD	DX,0400H			; POINT TO NEXT 16K BLOCK
	ADD	BX,16				; BUMP COUNT BY 16KB
	CMP	DH,0B0H
	JNZ	FILL_LOOP			; AREA YET ?(B0000H)
	JMP	HOW_BIG_END
HOW_BIG_END:
	CMP	DH,0A0H				; 1ST 16KB OK
	JZ	HB_ERROR_EXIT
RESUME:
	ADD	WORD PTR[BP][4],BX		; SAVE BUFFER FOUND
	MOV	AX,0
HB_ERROR_EXIT:
	RET
HOW_BIG ENDP

;---------------------------------------
;SUBROUTINES FOR POWER ON DIAGNOSTICS  :
;-----------------------------------------------------------------
;THIS PROCEDURE WILL ISSUE ONE LONG TONE (3 SEC) AND ONE OR	 :
;MORE SHORT TONES (1 SEC) TO INDICATE A FAILURE ON THE PLANAR	 :
;BOARD ,A BAD RAM MODULE,OR A PROBLEM WITH THE CRT.		 :
;ENTRY REQUIREMENTS:						 :
;	DH=NUMBER OF LONG TONES TO BEEP				 :
;	DL=NUMBER OF SHORT TONES TO BEEP.			 :
;-----------------------------------------------------------------
ERR_BEEP   PROC	   NEAR
	PUSHF					; SAVE FLAGS
	CLI					; DISABLE SYSTEM INTS
	PUSH	DS
	CALL	DDS
	ASSUME	DS:ABS0
	OR	DH,DH				; ANY LONG TONES TO BEEP
	JZ	G3				; NO, DO THE SHORT ONES
G1:						; LONG BEEP
	MOV	BL,6				; COUNTER FOR BEEPS
	CALL	BEEP				; DO THE BEEP
G2:
	LOOP	G2				; DELAY BETWEEN BEEPS
	DEC	DH				; ANY MORE TO DO
	JNZ	G1				; DO IT
G3:
	MOV	BL,1				; COUNTER FOR A SHORT BEEP
	CALL	BEEP				; DO IT
G4:
	LOOP	G4				; DELAY BETWEEN BEEPS
	DEC	DL				; DONE WITH SHORT BEEPS
	JNZ	G3				; DO MORE
G5:
	LOOP G5					; DELAY BEFORE RETURN
G6:
	LOOP G6
	POP	DS				; RESTORE CONTENTS OF DS
	POPF					; RESTORE FLAGS
	RET
ERR_BEEP	ENDP

	SUBTTL

