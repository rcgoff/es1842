	SUBTTL V1-5.INC
	PAGE

CALC_CURSOR	PROC	NEAR
	ASSUME	DS:ABS0
	CMP	CH,0				; CHECK FOR FULL HEIGHT
	JNE	CC_1				; NORMAL CHECK
	INC	CL				; ADJUST END VALUE
	JMP	SHORT	CALC_OUT
CC_1:
	INC	CL				; ADJUST FOR EGA REGISTERS
	CMP	CL,BYTE PTR POINTS		; WILL IT WRAP
	JB	CALC_OUT			; NO, ITS OK
	SUB	CL,CL				; EGA METHOD FOR CURSOR END
CALC_OUT:
	PUSH	CX				; SAVE CURSOR TYPE VALUE
	SUB	CL,CH				; END - START
	CMP	CL,010H				; LOW NIBBLE EQUAL
	POP	CX
	JNE	COMP_4				; RESTORE
	INC	CL
COMP_4:						; ADD 1 FOR CORRECT CURSOR
	RET					; BACK TO CALLER
CALC_CURSOR	ENDP

;----------------------------------------------------------------
; SET CTYPE	SET CURSOR TYPE					:
;	THIS ROUTINE SETS THE CURSOR VALUE			:
; INPUT								:
;	(CX) HAS CURSOR VALUE CH-START LINE, CL-STOP LINE	:
; OUTPUT							:
;	NONE							:
;----------------------------------------------------------------
	CUT_OFF		EQU	4
AH1:
	ASSUME	DS:ABS0
	MOV	AH,C_CRSR_START			; CRTC REG FOR CURSOR SET
	MOV	CURSOR_MODE,CX			; SAVE IN DATA AREA
	TEST	INFO,8				; EGA ACTIVE BIT
	JNZ	DO_SET				; 0=EGA, 1=OLD CARDS

;----- THIS SECTION WILL EMULATE CURSOR OFF ON THE EGA

	MOV	AL,CH				; GET START VALUE
	AND	AL,060H				; TURN OFF CURSOR ?
	CMP	AL,020H				; TEST THE BITS
	JNE	AH1_A				; SKIP CURSOR OFF
	MOV	CX,01E00H			; EMULATE CURSOR OFF
	JMP	SHORT DO_SET

;----- THIS SECTION : ADJUST THE CURSOR AND TEST FOR ENHANCED OPERATION

AH1_A:
	TEST	INFO,1				; CURSOR EMULATE BIT
	JNZ	DO_SET				; 0=EMULATE, 1==VALUE AS-IS
	CMP	CRT_MODE,3			; POSSIBLE EMULATION
	JA	AH1_S				; NO, SET THE CURSOR TYPE
	CALL	BRST_DET			; SEE IF EMULATE MODE
	JNC	AH1_S				; NOT EMULATING
	CMP	CH,CUT_OFF			; TEST START
	JBE	AH1_B				; SKIP ADJUST
	ADD	CH,5				; ADJUST
AH1_B:
	CMP	CL,CUT_OFF			; TEST END
	JBE	AH1_S				; SKIP ADJUST
	ADD	CL,5
AH1_S:
	CALL	CALC_CURSOR			; ADJUST END REGISTER
DO_SET:
	CALL	M16				; OUTPUT CX REG
	JMP	V_RET				; RETURN TO CALLER

;----- THIS ROUTINE OUTPUTS THE CX REGISTER TO THE CRTC REGS NAMED IN AH

M16:
	MOV	DX,ADDR_6845			; ADDRESS REGISTER
	MOV	AL,CH				; DATA
	CALL	OUT_DX				; OUTPUT THE VALUE
	INC	AH				; NEXT REGISTER
	MOV	AL,CL				; SECOND DATA VALUE
	CALL	OUT_DX				; OUTPUT THE VALUE
	RET					; ALL DONE

;----------------------------------------------------------------
; POSITION							:
;	THIS SERVICE ROUTINE CALCULATES THE REGEN BUFFER	:
;	ADDRESS OF A CHARACTER IN THE ALPHA MODE		:
; INPUT								:
;	AX = ROW, COLUMN POSITION				:
; OUTPUT							:
;	AX = OFFSET OF CHAR POSITION IN REGEN BUFFER		:
;----------------------------------------------------------------
POSITION	PROC	NEAR
	PUSH	BX				; SAVE REGISTER
	MOV	BX,AX
	MOV	AL,AH				; ROWS TO AL
	MUL	BYTE PTR CRT_COLS		; DETERMINE BYTES TO ROW
	XOR	BH,BH				; ZERO OUT
	ADD	AX,BX				; ADD IN COLUMN VALUE
	SAL	AX,1				; * 2 FOR ATTRIBUTE BYTES
	POP	BX				; RESTORE REGISTER
	RET
POSITION	ENDP

;----------------------------------------------------------------
; SET_CPOS	SET CURSOR POSITION				:
;	THIS ROUTINE SETS THE CURRENT CURSOR POSITION TO THE	:
;	NEW X-Y VALUES PASSED					:
; INPUT								:
;	DX - ROW,COLUMN OF NEW CURSOR				:
;	BH - DISPLAY PAGE OF CURSOR				:
; OUTPUT							:
;	CURSOR IS SET AT CRTC IF DISPLAY PAGE IS CURRENT	:
;	DISPLAY							:
;----------------------------------------------------------------
AH2:
	CALL	SET_CPOS
	JMP	V_RET

SET_CPOS:
	MOV	CL,BH
	XOR	CH,CH				; ESTABLISH LOOP COUNT
	SAL	CX,1				; WORD OFFSET
	MOV	SI,CX				; USE INDEX REGISTER
	MOV	[SI+OFFSET CURSOR_POSN],DX	; SAVE THE POINTER
	CMP	ACTIVE_PAGE,BH
	JNZ	M17				; SET_CPOS_RETURN
	MOV	AX,DX				; GET ROW/COLUMN TO AX
	CALL	M18				; CURSOR_SET
M17:						; SET_CPOS_RETURN
	RET

;----- SET CURSOR POSITION, AX HAS ROW/COLUMN FOR CURSOR

M18	PROC	NEAR
	CALL	POSITION			; DETERMINE LOC IN REGEN
	MOV	CX,AX
	ADD	CX,CRT_START			; ADD IN THE START ADDR
						;  FOR THIS PAGE
	SAR	CX,1				; / 2 FOR CHAR ONLY COUNT
	MOV	AH,C_CRSR_LOC_HGH		; REGISTER NUMBER FOR CURSOR
	CALL	M16				; SET VALUE TO CRTC
	RET
M18	ENDP

;----------------------------------------------------------------
; READ_CURSOR							:
;	THIS ROUTINE READS THE CURRENT CURSOR VALUE FROM	:
;	MEMORY AND SENDS IT BACK TO THE CALLER			:
; INPUT								:
;	BH - PAGE OF CURSOR					:
; OUTPUT							:
;	DX - SET CURSOR POSITION, AX HAS ROW/COLUMN FOR CURSOR	:
;	CX - RCURRENT CURSOR POSITION				:
;----------------------------------------------------------------
AH3:
	MOV	BL,BH				; PAGE VALUE
	XOR	BH,BH				; ZERO UPPER BYTE
	SAL	BX,1				; WORD OFFSET
	MOV	DX,[BX + OFFSET CURSOR_POSN]	; GET CURSOR FOR THIS PAGE
	MOV	CX,CURSOR_MODE			; GET THE CURSOR MODE
	POP	DI
	POP	SI
	POP	BX
	POP	AX				; DISCARD CX
	POP	AX				; DISCARD DX
	POP	DS
	POP	ES
	POP	BP
	IRET

;-----	READ LIGHT PEN POSITION

AH4:
	MOV	AL,CRT_MODE
	CMP	AL,07H
	JA	READ_LPEN

	TEST	INFO,2
	JZ	EGA_IS_COLOR

;----- MONOCHROME HERE ( MONOC BIT 1)

	CMP	AL,07H
	JE	READ_LPEN
	JMP	OLD_LP

;----- EGA IS COLOR HERE (MONOC BIT 0)

EGA_IS_COLOR:
	CMP	AL,06H
	JBE	READ_LPEN
OLD_LP:
	INT	42H				; CALL EXISTING CODE
	POP	DI
	POP	SI
	ADD	SP,6				; DISCARD SAVED BX,CX,DX
	POP	DS
	POP	ES
	POP	BP
	IRET

;----------------------------------------------------------------
; LIGHT PEN							:
;	THIS ROUTINE TESTS THE LIGHT PEN SWITCH AND THE LIGHT	:
;	PEN TRIGGER. IF BOTH ARE SET, THE LOCATION OF THE LIGHT :
;	PEN IS DETERMINED. OTHERWISE, A RETURN WITH NO		:
;	INFORMATION IS MADE.					:
; ON EXIT							:
;	(AH) = 0 IF NO LIGHT PEN INFORMATION IS AVAILABLE	:
;		 BX,CX,DX ARE DESTROYED				:
;	(AH) = 1 IF LIGHT PEN IS AVAILABLE			:
;		 (DH,DL) = ROW,COLUMN OF CURRENT LIGHT PEN	:
;			   POSITION				:
;		 (CH) = RASTER POSITION (OLD MODES)		:
;		 (CX) = RASTER POSITION (NEW MODES)		:
;		 (BX) = BEST GUESS AT PIXEL HORIZONTAL POSITION :
;----------------------------------------------------------------
	ASSUME	CS:CODE,DS:ABS0
;----- SUBTRACT_TABLE
V1	LABEL	BYTE
	DB	006H,006H,007H,007H,005H,005H	; 0-5
	DB	004H,005H,000H,000H,000H,000H	; 6-B
	DB	000H,005H,006H,004H,004H,004H	; C-11
	DB	004H,006H,006H,004H,007H,004H	; 12-17
	DB	007H,004H			; 18-19

READ_LPEN	PROC	NEAR

;----- WAIT FOR LIGHT PEN TO BE DEPRESSED

	MOV	DX,ADDR_6845			; GET BASE ADDRESS OF 6845
	ADD	DX,6				; POINT TO STATUS REGISTER
	IN	AL,DX				; GET STATUS REGISTER
	TEST	AL,4				; TEST LIGHT PEN SWITCH
	MOV	AH,0				; SET NO LIGHT PEN RETURN
	JZ	V9				;  CODE
	JMP	V6				; NOT SET, RETURN

;----- NOW TEST FOR LIGHT PEN TRIGGER

V9:
	TEST	AL,2				; TEST LIGHT PEN TRIGGER
	JNZ	V7A				; RETURN WITHOUT RESETTING
						;  TRIGGER
	JMP	V7				; EXIT LIGHT PEN ROUTINE

;----- TRIGGER HAS BEEN SET, READ THE VALUE IN

V7A:

	MOV	AH,16				; LIGHT PEN REGISTERS

;----- INPUT REGS POINTED TO BY AH, AND CONVERT TO ROW COLUMN IN DX

	MOV	DX,ADDR_6845			; ADDRESS REGISTER
	MOV	AL,AH				; REGISTER TO READ
	OUT	DX,AL				; SET IT UP
	INC	DX				; DATA REGISTER
	PUSH	AX
	IN	AL,DX				; GET THE VALUE
	MOV	CH,AL				; SAVE IN CX
	POP	AX
	DEC	DX				; ADDRESS REGISTER
	INC	AH
	MOV	AL,AH				; SECOND DATA REGISTER
	OUT	DX,AL
	INC	DX				; POINT TO DATA REGISTER
	IN	AL,DX				; GET THE 2ND DATA VALUE
	MOV	AH,CH				; AX HAS INPUT VALUE

;----- AX HAS THE VALUE READ IN FROM THE 6845

	MOV	BL,CRT_MODE
	SUB	BH,BH				; MODE VALUE TO BX
	MOV	BL,CS:V1[BX]			; AMOUNT TO SUBTRACT
	SUB	AX,BX				; TAKE IT AWAY
	MOV	BX,CRT_START			; SCREEN ADDRESS
	SHR	BX,1				; DIVIDE BY 2
	SUB	AX,BX				; ADJUST TO ZERO START
	JNS	V2				; IF POSITIVE, GET MODE
	SUB	AX,AX				; <0 PLAYS AS 0

;----- DETERMINE MODE OF OPERATION

V2:						; DETERMINE_MODE
	MOV	CL,3				; SET *8 SHIFT COUNT
	CMP	CRT_MODE,4			; GRAPHICS OR ALPHA
	JB	V4				; ALPHA_PEN
	CMP	CRT_MODE,7
	JE	V4				; ALPHA_PEN

	CMP	CRT_MODE,06H
	JA	V8
	JNE	V8X
	SHR	AX,1

;----- OLD GRAPHICS MODES

V8X:
	MOV	DL,40				; DIVISOR FOR GRAPHICS
	DIV	DL				; ROW(AL) AND COLUMN(AH)
						;  AL RANGE 0-99,
						;  AH RANGE 0-39
;----- DETERMINE GRAPHIC ROW POSITION

	MOV	CH,AL				; SAVE ROW VALUE IN CH
	ADD	CH,CH				; *2 FOR EVEN/ODD FIELD
	MOV	BL,AH				; COLUMN VALUE TO BX
	SUB	BH,BH				; *8 FOR MEDIUM RES
	CMP	CRT_MODE,6			; MEDIUM OR HIGH RES
	JNE	V3				; NOT_HIGH_RES
	MOV	CL,4				; SHIFT VALUE FOR HIGH RES
	SAL	AH,1				; COLUMN VALUE *2 FOR HIGH RES
V3:						; NOT_HIGH_RES
	SHL	BX,CL				; *16 FOR HIGH RES

;----- DETERMINE ALPHA CHAR POSITION

	MOV	DL,AH				; COLUMN VALUE FOR RETURN
	MOV	DH,AL				; ROW VALUE
	SHR	DH,1				; DIVIDE BY 4
	SHR	DH,1				; FOR VALUE IN 0-24 RANGE
	JMP	V5				; LIGHT_PEN_RETURN_SET
V8:

;----- NEW GRAPHICS MODES

	CWD					; PREPARE TO DIVIDE
	DIV	CRT_COLS			; AX = ROW, DX = COLUMN
	MOV	BX,DX				; SAVIE REMAINDER
	SAL	BX,CL				; PEL COLUMN
	MOV	CX,AX				; PEL ROW
	PUSH	DX				; SAVE FROM DIVIDE
	CWD					; PREPARE TO DIVIDE
	DIV	POINTS				; DIVIDE BY BYTES/CHAR
	POP	DX				; RECOVER
	MOV	DH,AL				; CHARACTER ROW
	JMP	V5

;----- ALPHA MODE ON LIGHT PEN
V4:						; ALPHA PEN
	DIV	BYTE PTR CRT_COLS		; ROW,COLUMN VALUE
	MOV	DH,AL				; ROWS TO DH
	MOV	DL,AH				; COLS TO DL
	MOV	BL,AH				; COLUMN VALUE
	XOR	BH,BH				;  TO BX
	SAL	BX,CL
	MUL	BYTE PTR POINTS
	MOV	CX,AX
V5:						; LIGHT_PEN_RETURN_SET
	MOV	AH,1				; INDICATE EVERTHING SET
V6:						; LIGHT_PEN_RETURN
	PUSH	DX				; SAVE RETURN VALUE
						;  (IN CASE)
	MOV	DX,ADDR_6845			; GET BASE ADDRESS
	ADD	DX,7				; POINT TO RESET PARM
	OUT	DX,AL				; ADDRESS, NOT DATA,
						;  IS IMPORTANT
	POP	DX				; RECOVER VALUE
V7:						; RETURN_NO_RESET
	POP	DI
	POP	SI
	ADD	SP,6				; DISCARD SAVED BX,CX,DX
	POP	DS
	POP	ES
	POP	BP
	IRET
READ_LPEN	ENDP

;----------------------------------------------------------------
; ACT_DISP_PAGE		SELECT ACTIVE DISPLAY PAGE		:
;	THIS ROUTINE SETS THE ACTIVE DISPLAY PAGE, ALLOWING	:
;	FOR MULTIPLE PAGES OF DISPLAYED VIDEO.			:
; INPUT								:
;	AL HAS THE NEW ACTIVE DISPLAY PAGE			:
; OUTPUT							:
;	THE CRTC IS RESET TO DISPLAY THAT PAGE			:
;----------------------------------------------------------------
AH5:
	MOV	ACTIVE_PAGE,AL			; SAVE ACTIVE PAGE VALUE
	MOV	CX,CRT_LEN			; GET SAVED LENGTH OF
						;  REGEN BUFFER
	CBW					; CONVERT AL TO WORD
	PUSH	AX				; SAVE PAGE VALUE
	MUL	CX				; DISPLAY PAGE TIMES
						;  REGEN LENGTH
	MOV	CRT_START,AX			; SAVE START ADDRESS FOR
						;  LATER REQUIREMENTS
	MOV	CX,AX				; START ADDRESS TO CX
	MOV	BL,CRT_MODE
	CMP	BL,7				; DO NOT DIVIDE BY TWO
	JA	ADP_1
ADP_2:
	SAR	CX,1				; / 2 FOR CRTC HANDLING
ADP_1:
	MOV	AH,C_STRT_HGH			; REG FOR START ADDRESS
	CALL	M16
	POP	BX				; RECOVER PAGE VALUE
	SAL	BX,1				; *2 FOR WORD OFFSET
	MOV	AX,[BX + OFFSET CURSOR_POSN]	; GET CURSOR FOR THIS PAGE
	CALL	M18				; SET THE CURSOR POSITION
	JMP	V_RET

	SUBTTL

