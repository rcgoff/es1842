	SUBTTL	VGRW.INC
	PAGE

	ASSUME	DS:ABS0
FIND_POSITION	PROC	NEAR
	MOV	CL,BH				; DISPLAY PAGE TO CX
	XOR	CH,CH
	MOV	SI,CX				; MOVE TO SI FOR INDEX
	SAL	SI,1				; * 2 FOR WORD OFFSET
	MOV	AX,[SI+ OFFSET CURSOR_POSN]	; ROW/COLUMN OF THAT PAGE
	XOR	BX,BX				; SET START ADDRESS TO 0
	JCXZ	P5				; NO_PAGE
P4:						; PAGE_LOOP
	ADD	BX,CRT_LEN			; LENGTH OF BUFFER
	LOOP	P4
P5:						; NO_PAGE
	CALL	POSITION			; DETERMINE LOC IN REGEN
	ADD	BX,AX				; ADD TO START OF REGEN
	RET
FIND_POSITION	ENDP

;--------------------------------------------------------
; EXPAND_MED_COLOR					:
;	THIS ROUTINE EXPANDS THE LOW 2 BITS IN BL TO	:
;	FILL THE ENTIRE BX REGISTER			:
; ENTRY							:
;	BL = COLOR TO BE USED ( LOW 2 BITS )		:
; EXIT							:
;	BX = COLOR TO BE USED ( 8 REPLICATIONS OF THE	:
;	2 COLOR BITS )					:
;--------------------------------------------------------
S19	PROC	NEAR
	AND	BL,3				; ISOLATE THE COLOR BITS
	MOV	AL,BL				; COPY TO AL
	PUSH	CX				; SAVE REGISTER
	MOV	CX,3				; NUMBER OF TIMES
S20:
	SAL	AL,1
	SAL	AL,1				; LEFT SHIFT BY 2
	OR	BL,AL				; ANOTHER COLOR VERSION
						;  INTO BL
	LOOP	S20				; FILL ALL OF BL
	MOV	BH,BL				; FILL UPPER PORTION
	POP	CX				; REGISTER BACK
	RET					; ALL DONE
S19	ENDP
;--------------------------------------------------------
; EXPAND_BYTE						:
;	THIS ROUTINE TAKES THE BYET IN AL AND DOUBLES	:
;	ALL OF THE BITS, TURNING THE 8 BITS INTO	:
;	16 BITS. THE RESULT IS LEFT IN AX		:
;--------------------------------------------------------
S21	PROC	NEAR
	PUSH	DX				; SAVE REGISTERS
	PUSH	CX
	PUSH	BX
	SUB	DX,DX				; RESULT REGISTER
	MOV	CX,1				; MASK REGISTER
S22:
	MOV	BX,AX				; BASE INTO TEMP
	AND	BX,CX				; USE MASK TO EXTRACT BIT
	OR	DX,BX				; PUT INTO RESULT RECISTER
	SHL	AX,1
	SHL	CX,1				; SHIFT BASE AND MASK BY 1
	MOV	BX,AX				; BASE TO TEMP
	AND	BX,CX				; EXTRACT THE SAME BIT
	OR	DX,BX				; PUT INTO RESULT
	SHL	CX,1				; SHIFT ONLY MASK NOW,
						;  MOVING TO NEXT BASE
	JNC	S22				; USE MASK BIT COMING OUT
						;  TO TERMINATE
	MOV	AX,DX				; RESULT TO PARM REGISTER
	POP	BX
	POP	CX				; RECOVER REGISTERS
	POP	DX
	RET					; ALL DONE
S21	ENDP

S26	PROC	NEAR
	MOV	AX,CURSOR_POSN			; GET CURRENT CURSOR
GRAPH_POSN	LABEL	NEAR
	PUSH	BX				; SAVE REGISTER
	MOV	BX,AX				; SAVE A COPY OF CURSOR
	MOV	AL,AH				; GET ROWS TO AL
	MUL	BYTE PTR CRT_COLS		; MULTIPLY BY BYTES/COLUMN
	SHL	AX,1				; *4 SINCE 4 ROWS/BYTE
	SHL	AX,1
	SUB	BH,BH				; ISOLATE COLUMN VALUE
	ADD	AX,BX				; DETERMINE OFFSET
	POP	BX				; RECOVER POINTER
	RET					; ALL DONE
S26	ENDP

;----------------------------------------------------------------
; GR_CUR							:
; ENTRY								:
;	BH = DISPLAY PAGE					:
; EXIT								:
;	AX = CURSOR POSITION FOR REQUESTED PAGE			:
;----------------------------------------------------------------
GR_CUR:
	ASSUME	DS:ABS0
	PUSH	BX				; SAVE REGISTER
	MOV	BL,BH				; GET TO LOW BYTE
	SUB	BH,BH				; ZERO HIGH BYTE
	SAL	BX,1				; *2 FOR WORD COUNT
	MOV	AX,[BX + OFFSET CURSOR_POSN]	; CURSOR, REQUESTED PAGE
	POP	BX				; RECOVER REGISTER
;----------------------------------------------------------------
; GRX_PSN							:
; ENTRY								:
;	AX = CURSOR POSITION IN DESIRED PAGE			:
;	BH = DESIRED PAGE					:
; EXIT								:
;	AX = BYTE OFFSET INTO REGEN				:
;----------------------------------------------------------------
GRX_PSN PROC	NEAR
	PUSH	BX				; SAVE
	PUSH	CX				; SAVE
	PUSH	DX				; SAVE
	SUB	CH,CH				; ZERO
	MOV	CL,BH				; PAGE NUMBER
	MOV	BX,AX				; ROW, COLUMN
	MOV	AL,AH				; ROW
	MUL	BYTE PTR CRT_COLS		; ROW * COLUMNS/ROW
	MUL	POINTS				; BYTES PER ROW
	SUB	BH,BH				; ZERO TO LEAVE COL VALUE
	ADD	AX,BX				; ADD IN COLUMN
	MOV	BX,CRT_LEN			; PAGE LENGTH
	JCXZ	GP_2				; NO PAGE OFFSET
GP_3:
	ADD	AX,BX				; ADD IN THE PAGE LENGTH
	LOOP	GP_3				; DO FOR NUMBER OF PAGES
GP_2:
	POP	DX				; RECOVER
	POP	CX				; RECOVER
	POP	BX				; RECOVER
	RET
GRX_PSN ENDP

MK_ES:
	MOV	SI,0B800H
	MOV	DI,EQUIP_FLAG
	AND	DI,030H
	CMP	DI,030H
	JNE	P6_A
	MOV	SI,0B000H
P6_A:
	MOV	ES,SI
	RET

;--------------------------------------------------------
; READ_AC_CURRENT					:
;	THIS ROUTINE READS THE ATTRIBUTE AND CHARACTER	:
;	AT THE CURRENT CURSOR POSITION AND RETURNS THEM :
;	TO THE CALLER					:
; INPUT							:
;	(AH) = CURRENT CRT MODE				:
;	(BH) = DISPLAY PAGE ( ALPHA MODES ONLY )	:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN SEGMENT				:
; OUTPUT						:
;	(AL) = CHAR READ				:
;	(AH) = ATTRIBUTE READ				:
;--------------------------------------------------------
	ASSUME	CS:CODE,DS:ABS0,ES:NOTHING
READ_AC_CURRENT PROC	NEAR
	CALL	MK_ES
	CALL	FIND_POSITION
	MOV	SI,BX				; ADDRESSING IN SI

	MOV	DX,ADDR_6845			; GET BASE ADDRESS
	ADD	DX,6				; POINT AT STATUS PORT

	TEST	INFO,4

	PUSH	ES
	POP	DS				; SEGMENT FOR QUICK ACCESS

	JZ	P3A

;----- WAIT FOR HORIZONTAL RETRACE

P2:						; WAIT FOR RETRACE LOW
	IN	AL,DX				; GET STATUS
	TEST	AL,1				; IS HORZ RETRACE LOW
	JNZ	P2				; WAIT UNTIL IT IS
	CLI					; NO MORE INTERRUPTS
P3:						; WAIT FOR RETRACE HIGH
	IN	AL,DX				; GET STATUS
	TEST	AL,1				; IS IT HIGH
	JZ	P3				; WAIT UNTIL IT IS
P3A:
	LODSW					; GET THE CHAR/ATTR
	JMP	V_RET
READ_AC_CURRENT ENDP

;--------------------------------------------------------
; MED_READ_BYTE						:
;	THIS ROUTINE WILL TAKE 2 BYTES FROM THE REGEN	:
;	BUFFER, COMPARE AGAINST THE CURRENT FOREGROUND	:
;	COLOR, AND PLACE THE CORRESPONDING ON/OFF BIT	:
;	PATTERN INTO THE CURRENT POSITION IN THE SAVE	:
;	AREA						:
; ENTRY							:
;	SI,DS = POINTER TO REGEN AREA OF INTEREST	:
;	BX = EXPANDED FOREGROUND COLOR			:
;	BP = POINTER TO SAVE AREA			:
; EXIT							:
;	BP IS INCREMENT AFTER SAVE			:
;--------------------------------------------------------
S23	PROC	NEAR
	MOV	AH,[SI]				; GET FIRST BYTE
	MOV	AL,[SI+1]			; GET SECOND BYTE
	MOV	CX,0C000H			; 2 BIT MASK TO TEST
						;  THE ENTRIES
	MOV	DL,0				; RESULT REGISTER
S24:
	TEST	AX,CX				; IS THIS BACKGROUND?
	CLC					; CLEAR CARRY IN HOPES
						;  THAT IT IS
	JZ	S25				; IF 0, IT IS BACKGROUND
	STC					; WASN'T, SO SET CARRY
S25:
	RCL	DL,1				; MOVE THAT BIT INTO THE
	SHR	CX,1				;  RESULT
	SHR	CX,1				; MOVE THE MASK TO THE
						;  RIGHT BY 2 BITS
	JNC	S24				; DO IT AGAIN IF MASK
						;  DIDN'T FALL OUT
	MOV	[BP],DL				; STORE RESULT IN SAVE
	INC	BP				; ADJUST POINTER
	RET					; ALL DONE
S23	ENDP


GRAPHICS_READ	PROC	NEAR
	CALL	MK_ES
	CALL	S26				; CONVERTED TO OFFSET
	MOV	SI,AX				; SAVE IN SI
	SUB	SP,8				; ALLOCATE SPACE TO SAVE
						;  THE READ CODE POINT
	MOV	BP,SP				; POINTER TO SAVE AREA

;----- DETERMINE GRAPHICS MODES

	CMP	CRT_MODE,6
	PUSH	ES
	POP	DS				; POINT TO REGEN SEGMENT
	JC	S13P				; MEDIUM RESOLUTION

;----- HIGH RESOLUTION READ

;----- GET VALUES FROM REGEN BUFFER AND CONVERT TO CODE POINT

	MOV	DH,4				; NUMBER OF PASSES
S12P:
	MOV	AL,[SI]				; GET FIRST BYTE
	MOV	[BP],AL				; SAVE IN STORAGE AREA
	INC	BP				; NEXT LOCATION
	MOV	AL,[SI+2000H]			; GET LOWER REGION BYTE
	MOV	[BP],AL				; ADJUST AND STORE
	INC	BP
	ADD	SI,80				; POINTER INTO REGEN
	DEC	DH				; LOOP CONTROL
	JNZ	S12P				; DO IT SOME MORE
	JMP	S15P				; GO MATCH THE SAVED CODE
						;  POINTS

;----- MEDIUM RESOLUTION READ

S13P:						; MED_RES_READ
	SAL	SI,1				; OFF5ET*2, 2 BYTES/CHAR
	MOV	DH,4				; NUMBER OF PASSES
S14P:
	CALL	S23				; GET PAIR BYTES
						;  INTO SINGLE SAVE
	ADD	SI,2000H			; GO TO LOWER REGION
	CALL	S23				; GET THIS PAIR INTO SAVE
	SUB	SI ,2000H-80			; ADJUST POINTER BACK INTO
	DEC	DH				; UPPER
	JNZ	S14P				; KEEP GOING UNTIL 8 DONE

;----- SAVE AREA HAS CHARACTER IN IT, MATCH IT

S15P:						; FIND_CHAR
	PUSH	DS
	CALL	DDS
	LES	DI,GRX_SET			; ESTABLISH ADDRESSING
	POP	DS
	SUB	BP,8				; ADJUST POINTER TO
						;  BEGINNING OF SAVE AREA
	MOV	SI,BP
	CLD					; ENSURE DIRECTION
	MOV	AL,0				; CURRENT CODE POINT BEING
S16P:						;  MATCHED
	PUSH	SS				; ADDRESSING TO STACK
	POP	DS				; FOR THE STRING COMPARE
	MOV	DX,128				; NUMBER TO TEST AGAINST
S17P:
	PUSH	SI				; SAVE SAVE AREA POINTER
	PUSH	DI				; SAVE CODE POINTER
	MOV	CX,8				; NUMBER OF BYTES TO MATCH
	REPE	CMPSB				; COMPARE THE 8 BYTES
	POP	DI				; RECOVER THE POINTERS
	POP	SI
	JZ	S18P				; IF ZERO FLAG SET,
						;  THEN MATCH OCCURRED
	INC	AL				; NO MATCH, MOVE TO NEXT
	ADD	DI,8				; NEXT CODE POINT
	DEC	DX				; LOOP CONTROL
	JNZ	S17P				; DO ALL OF THEM

;----- CHAR NOT MATCHED, MIGHT BE IN USER SUPPLIED SECOND HALF

	CMP	AL,0				; AL <> 0 IF ONLY 1ST
						;  HALF SCANNED
	JE	S18P				; IF = 0, THEN ALL HAS
						;  BEEN SCANNED
	ASSUME	DS:ABS0
	CALL	DDS
	LES	DI,EXT_PTR			; GET POINTER
	MOV	AX,ES				; SEE IF THE PNTR EXISTS
	OR	AX,DI				; IF ALL 0, DOESN'T EXIST
	JZ	S18P				; NO SENSE LOOKING
	MOV	AL,128				; ORIGIN FOR SECOND HALF
	JMP	S16P				; GO BACK AND TRY FOR IT

;----- CHARACTER IS FOUND ( AL=0 IF NOT FOUND )

S18P:
	ADD	SP,8				; READJUST THE STACK,
						;  THROW AWAY SAVE
	JMP	V_RET				; ALL DONE
GRAPHICS_READ	ENDP


;----- READ CHARACTER/ATTRIBUTE AT CURRENT CURSOR POSITION

AH8S:
	JMP	READ_AC_CURRENT

AH8:
	ASSUME	DS:ABS0
	MOV	AH,CRT_MODE			; GET THE CURRENT MODE
	CMP	AH,07H
	JE	AH8S
	CMP	AH,03H
	JBE	AH8S
	CMP	AH,06H
	JA	Z_1
	JMP	GRAPHICS_READ
Z_1:
	CMP	AH,0FH
	JB	GRX_RD2
	CALL	MEM_DET
	JC	GRX_RD2
	JMP	SHORT GRX_RD1
	CMP	AH,0DH				; RANGE TEST
	JAE	GRX_RD2				; FOUR MAP READ
	MOV	AL,0
	JMP	V_RET

GRX_RD1 PROC	NEAR
	ASSUME	DS:ABS0
	SRLOAD	ES,0A000H			; REGEN SEGEMNT
	CALL	GR_CUR				; BYTE OFFSET INTO REGEN
	MOV	SI,AX				; SAVE IN SI
	MOV	BX,POINTS			; BYTES PER CHARACTER
	SUB	SP,BX				; ALLOCATE SPACE TO SAVE
						;  THE READ CODE POINT
	MOV	BP,SP				; POINTER TO SAVE AREA

;----- GET VALUES FROM REGEN BUFFER AND CONVERT TO CODE POINT

	PUSH	BX				; SAVE BYTES PER CHARACTER
	AND	AL,1				; ODD OR EVEN BYTE
	MOV	CL,AL				; USE FOR SHIFT
	MOV	AL,5				; COLOR COMP VALUE (C0-C2)
	SHL	AL,CL				; (C1-C3) IF ODD BYTE
	MOV	AH,G_COLOR			; COLOR COMPARE REGISTER
	MOV	DH,3
	MOV	DL,GRAPH_ADDR
	CALL	OUT_DX				; SET GRAPHICS CHIP
	MOV	AX,518H				; READ MODE
	CALL	OUT_DX				; SET GRAPHICS CHIP
S12_1:
	MOV	AL,ES:[SI]			; GET FIRST BYTE
	NOT	AL
	MOV	SS:[BP],AL			; SAVE IN STORAGE AREA
	INC	BP				; NEXT LOCATION
	ADD	SI,CRT_COLS			; POINTER INTO REGEN
	DEC	BX				; LOOP CONTROL
	JNZ	S12_1				; DO IT SOME MORE
	POP	BX				; RECOVER BYTES PER CHAR
	MOV	AX,510H				; UNDO READ MODE
	JMP	GRX_RECG			; CHAR REGONTION ROUTINE
GRX_RD1 ENDP

GRX_RD2 PROC	NEAR
	ASSUME	DS:ABS0
	SRLOAD	ES,0A000H			; REGEN SEGMENT
	CALL	GR_CUR				; BYTE OFFSET INTO REGEN
	MOV	SI,AX				; SAVE IN SI
	MOV	BX,POINTS			; BYTES PER CHARACTER
	SUB	SP,BX				; ALLOCATE SPACE TO SAVE
						;  THE READ CODE POINT
	MOV	BP,SP				; POINTER TO SAVE AREA

;----- GET VALUES FROM REGEN BUFFER AND CONVERT TO CODE POINT

	MOV	DH,3
	MOV	DL,GRAPH_ADDR			; GRAPHICS CHIP
	MOV	AX,508H				; COLOR COMPARE
	CALL	OUT_DX				; SET THE REGISTER
	PUSH	BX				; SAVE BYTES PER CHARACTER
S12:
	MOV	AL,ES:[SI]			; GET COLOR COMPARED BYTE
	NOT	AL				; ADJUST
	MOV	SS:[BP],AL			; SAVE IN STORAGE AREA
	INC	BP				; NEXT LOCATION
	ADD	SI,CRT_COLS			; POINTER INTO REGEN
	DEC	BX				; LOOP CONTROL
	JNZ	S12				; DO IT SOME MORE
	POP	BX				; RECOVER BYTES PER CHAR
	MOV	AX,500H				; UNDO READ MODE
GRX_RD2 ENDP

GRX_RECG:

;----- SAVE AREA HAS CHARACTER IN IT, MATCH IT

	CALL	OUT_DX				; SET READ MODE BACK
	LES	DI,GRX_SET			; GET FONT DEFINITIONS
	SUB	BP,BX				; ADJUST POINTER TO
						;  BEGINNING OF SAVE AREA
	MOV	SI,BP
	CLD					; ENSURE DIRECTION
	MOV	AL,0				; CODE POINT BEING MATCHED
	PUSH	SS				; ADDRESSING TO STACK
	POP	DS				;  FOR THE STRING COMPARE
	MOV	DX,256D				; NUMBER TO TEST AGAINST
S17_5:
	PUSH	SI				; SAVE SAVE AREA POINTER
	PUSH	DI				; SAVE CODE POINTER
	MOV	CX,BX				; NUMBER OF BYTES TO MATCH
	REPE	CMPSB				; COMPARE THE 8 BYTES
	POP	DI				; RECOVER THE POINTERS
	POP	SI
	JZ	S18_5				; IF ZFL SET, THEN MATCH
						;  OCCURRED
	INC	AL				; NO MATCH, ON TO NEXT
	ADD	DI,BX				; NEXT CODE POINT
	DEC	DX				; LOOP CONTROL
	JNZ	S17_5				; DO ALL OF THEM
S18_5:						; AL=CHAR, 0 IF NOT FOUND
	ADD	SP,BX				; READJUST THE STACK
	JMP	V_RET

;----- WRITE CHARACTER/ATTRIBUTE AT CURRENT CURSOR POSITION

;------------------------------------------------
; WRITE_AC_CURRENT				:
;	THIS ROUTINE WRITES THE ATTRIBUTE	:
;	AND CHARACTER AT THE CURRENT CURSOR	:
;	POSITION				:
; INPUT						:
;	(AH) = CURRENT CRT MODE			:
;	(BH) = DISPLAY PAGE			:
;	(CX) = COUNT OF CHARACTERS TO WRITE	:
;	(AL) = CHAR TO WRITE			:
;	(BL) = ATTRIBUTE OF CHAR TO WRITE	:
;	(DS) = DATA SEGMENT			:
;	(ES) = REGEN SEGMENT			:
; OUTPUT					:
;	NONE					:
;------------------------------------------------
AH9:
	ASSUME	DS:ABS0
	CALL	DDS
	MOV	AH,CRT_MODE

	CMP	AH,4				; IS THIS GRAPHICS
	JC	P6
	CMP	AH,7				; IS THIS BW CARD
	JE	P6
	JMP	GRAPHICS_WRITE
P6:						; WRITE_AC_CONTINUE
	CALL	MK_ES
	MOV	AH,BL				; GET ATTRIBUTE TO AH
	PUSH	AX				; SAVE ON STACK
	PUSH	CX				; SAVE WRITE COUNT
	CALL	FIND_POSITION
	MOV	DI,BX				; ADDRESS TO DI REGISTER
	POP	CX				; WRITE COUNT
	POP	BX				; CHARACTER IN BX REG
	MOV	DX,ADDR_6845			; GET BASE ADDRESS
	ADD	DX,6				; POINT AT STATUS PORT

;----- WAIT FOR HORIZONTAL RETRACE

P7:
	TEST	INFO,4
	JZ	P9A
P8:
	IN	AL,DX				; GET STATUS
	TEST	AL,1				; IS IT LOW
	JNZ	P8				; WAIT UNTIL IT IS
	CLI					; NO MORE INTERRUPTS
P9:
	IN	AL,DX				; GET STATUS
	TEST	AL,1				; IS IT HIGH
	JZ	P9				; WAIT UNTIL IT IS
P9A:
	MOV	AX,BX				; RECOVER THE CHAR/ATTR
	STOSW					; PUT THE CHAR/ATTR
	STI					; INTERRUPTS BACK ON
	LOOP	P7				; AS MANY TIMES
	JMP	V_RET

;----- WRITE CHARACTER ONLY AT CURRENT CURSOR POSITION

;------------------------------------------------
; WRITE_C_CURRENT				:
;	THIS ROUTINE WRITES THE CHARACTER AT	:
;	THE CURRENT CURSOR POSITION, ATTRIBUTE	:
;	UNCHANGED				:
; INPUT						:
;	(AH) = CURRENT CRT MODE			:
;	(BH) = DISPLAY PAGE			:
;	(CX) = COUNT OF CHARACTERS TO WRITE	:
;	(AL) = CHAR TO WRITE			:
;	(DS) = DATA SEGMENT			:
;	(ES) = REGEN SEGMENT			:
; OUTPUT					:
;	NONE					:
;------------------------------------------------
AHA:
	ASSUME	DS:ABS0
	CALL	DDS
	MOV	AH,CRT_MODE

	CMP	AH,4				; IS THIS GRAPHICS
	JC	P10
	CMP	AH,7				; IS THIS BW CARD
	JE	P10

	JMP	GRAPHICS_WRITE
P10:
	CALL	MK_ES
	PUSH	AX				; SAVE ON STACK
	PUSH	CX				; SAVE WRITE COUNT
	CALL	FIND_POSITION
	MOV	DI,BX				; ADDRESS TO DI
	POP	CX				; WRITE COUNT
	POP	BX				; BL HAS CHAR TO WRITE

;----- WAIT FOR HORIZONTAL RETRACE

	MOV	DX,ADDR_6845			; GET BASE ADDRESS
	ADD	DX,6				; POINT AT STATUS PORT
P11:
	TEST	INFO,4
	JZ	P13A
P12:
	IN	AL,DX				; GET STATUS
	TEST	AL,1				; IS IT LOW
	JNZ	P12				; WAIT UNTIL IT IS
	CLI					; NO MORE INTERRUPTS
P13:
	IN	AL,DX				; GET STATUS
	TEST	AL,1				; IS IT HIGH
	JZ	P13				; WAIT UNTIL IT IS
P13A:
	MOV	AL,BL				; RECOVER CHAR
	STOSB					; PUT THE CHAR/ATTR
	STI					; INTERRUPTS BACK ON
	INC	DI				; BUMP POINTER PAST ATTR
	LOOP	P11				;  AS REQUESTED
	JMP	V_RET

;----------------------------------------------------------------
; GRAPHICS WRITE						:
; THIS ROUTINE WRITES THE ASCII CHARACTER TO THE		:
; CURRENT POSITION ON THE SCREEN.				:
; ENTRY								:
;	AL = CHARACTER TO WRITE					:
;	BL = COLOR ATTRIBUTE TO BE USED FOR FOREGROUND COLOR	:
;	 IF BIT 7 IS SET, THE CHAR IS XOR'D INTO THE REGEN      :
;	 BUFFER (0 IS USED FOR THE BACKGROUND COLOR)		:
;	CX = NUMBER OF CHARS TO WRITE				:
;	DS = DATA SEGMENT					:
;	ES = REGEN SEGMENT					:
; EXIT								:
;	NOTHING IS RETURNED					:
;								:
; GRAPHICS READ							:
;	THIS ROUTINE READS THE ASCII CHARACTER AT THE CURRENT	:
;	CURSOR POSITION ON THE SCREEN BY MATCHING THE DOTS ON	:
;	THE SCREEN TO THE CHARACTER GENERATOR CODE POINTS	:
; ENTRY								:
;	NONE  (0 IS ASSUMED AS THE BACKGROUND COLOR)		:
; EXIT								:
;	AL = CHARACTER READ AT THAT POSITION (0 RETURNED IF	:
;	     NONE FOUND)					:
;								:
; FOR COMPATIBILITY ROUTINES, THE IMAGES USED TO FORM CHARS ARE :
;  CONTAINED IN ROM FOR THE 1ST 128 CHARS.  TO ACCESS CHARS	:
;  IN THE SECOND HALF, THE USER MUST INITIALIZE THE VECTOR AT	:
; INTERRUPT 1FH (LOCATION 0007CH) TO POINT TO THE USER		:
; SUPPLIED TABLE OF GRAPHIC IMAGES (8X8 BOXES).			:
; FAILURE TD DO SO WILL CAUSE IN STRANGE RESULTS		:
;----------------------------------------------------------------
	ASSUME	CS:CODE,DS:ABS0,ES:NOTHING
GRAPHICS_WRITE	PROC	NEAR
	CMP	AH,7
	JB	S1_A
	JMP	GRX_WRT
S1_A:
	CALL	MK_ES
	MOV	AH,0				; 0 TO HIGH OF CODE POINT
	PUSH	AX				; SAVE CODE POINT VALUE

;----- DETERMINE POSITION IN REGEN BUFFER TO PUT CODE POINTS

	CALL	S26				; LOC IN REGEN BUFFER
	MOV	DI,AX				; REGEN POINTER IN DI

;----- DETERMINE REGION TO GET CODE POINTS FROM

	POP	AX				; RECOVER CODE POINT
	CMP	AL,80H				; IS IT IN SECOND HALF
	JAE	S1				; YES

;----- IMAGE IS IN FIRST HALF, CONTAINED IN ROM

	LDS	SI,GRX_SET
	JMP	SHORT S2			; DETERMINE_MODE

;----- IMAGE IS IN SECOND HALF, IN USER RAM

S1:						; EXTEND_CHAR
	SUB	AL,80H				; 0 ORIGIN FOR SECOND HALF
	LDS	SI,EXT_PTR

;----- DETERMINE GRAPHICS MODE IN OPERATION

S2:						; DETERMINE_MODE
	SAL	AX,1				; MULTIPLY CODE POINT
	SAL	AX,1				;  VALUE BY 8
	SAL	AX,1
	ADD	SI,AX				; SI HAS OFFSET OF
	PUSH	DS				;  DESIRES CODES
	CALL	DDS
	CMP	CRT_MODE,6
	POP	DS
	JC	S7				; TEST FOR MEDIUM RES MODE

;----- HIGH RESOLUTION MODE

S3:						; HIGH_CHAR
	PUSH	DI				; SAVE REGEN POINTER
	PUSH	SI				; SAVE CODE POINTER
	MOV	DH,4				; NUMBER OF TIMES THROUGH
S4:						; LOOP
	LODSB					; GET BYTE FROM CODE POINT
	TEST	BL,80H				; SHOULD WE USE THE
	JNZ	S6				;  FUNCTION TO PUT CHAR IN
	STOSB					; STORE IN REGEN BUFFER
	LODSB
S5:
	MOV	ES:[DI+2000H-1],AL		; STORE IN SECOND HALF
	ADD	DI,79				; MOVE TO NEXT ROW IN REGEN
	DEC	DH				; DONE WITH LOOP
	JNZ	S4
	POP	SI
	POP	DI				; RECOVER REGEN POINTER
	INC	DI				; POINT TO NEXT CHAR POS
	LOOP	S3				; MORE CHARS TO WRITE
	JMP	V_RET
S6:
	XOR	AL,ES:[DI]			; XOR WITH CURRENT
	STOSB					; STORE THE CODE POINT
	LODSB					; AGAIN FOR ODD FIELD
	XOR	AL,ES:[DI+2000H-1]
	JMP	S5				; BACK TO MAINSTREAM

;----- MEDIUM RESOLUTION WRITE

S7:						; MED_RES_WRITE
	MOV	DL,BL				; SAVE HIGH COLOR BIT
	SAL	DI,1				; OFFSET*2, 2 BYTES/CHAR
	CALL	S19				; EXPAND BL TO FULL WORD
S8:						;  OF COLOR
	PUSH	DI				; SAVE REGEN POINTER
	PUSH	SI				; SAVE THE CODE POINTER
	MOV	DH,4				; NUMBER OF LOOPS
S9:
	LODSB					; GET CODE POINT
	CALL	S21				; DOUBLE UP ALL THE BITS
	AND	AX,BX				; CONVERT THEM TO FORE-
						;  GROUND COLOR (0 BACK)
	TEST	DL,80H				; IS THIS XOR FUNCTION
	JZ	S10				; NO, STORE IT IN AS IT IS
	XOR	AH,ES:[DI]			; DO FUNCTION WITH HALF
	XOR	AL,ES:[DI+1]			;  AND WITH OTHER HALF
S10:
	MOV	ES:[DI],AH			; STORE FIRST BYTE
	MOV	ES:[DI+1],AL			; STORE SECOND BYTE
	LODSB					; GET CODE POINT
	CALL	S21
	AND	AX,BX				; CONVERT TO COLOR
	TEST	DL,80H				; IS THIS XOR FUNCTION
	JZ	S11				; NO, JUST STORE THE VALUE
	XOR	AH,ES:[DI+2000H]		; FUNCTION WITH FIRST HALF
	XOR	AL,ES:[DI+2001H]		;  AND WITH SECOND HALF
S11:
	MOV	ES:[DI+2000H],AH
	MOV	ES:[DI+2000H+1],AL		; STORE IN SECOND PORTION
	ADD	DI,80				; POINT TO NEXT LOCATION
	DEC	DH
	JNZ	S9				; KEEP GOING
	POP	SI				; RECOVER CODE PONTER
	POP	DI				; RECOVER REGEN POINTER
	INC	DI				; POINT TO NEXT CHAR
	INC	DI
	LOOP	S8				; MORE TO WRITE
	JMP	V_RET
GRAPHICS_WRITE	ENDP

;----------------------------------------------------------------
; ENTRY								:
;	AL = CHAR TO WRITE					:
;	BH = DISPLAY PAGE					:
;	BL = ATTRIBUTE/COLOR					:
;	CX = COUNT OF CHARS TO WRITE				:
;----------------------------------------------------------------
GRX_WRT PROC	NEAR
	ASSUME	DS:ABS0, ES:NOTHING
	CMP	AH,0FH				; 640X350 GRAPHICS
	JB	NO_ADJ1
	CALL	MEM_DET				; BASE CARD
	JC	NO_ADJ1
	AND	BL,10000101B			; 85H, XOR C2 C0 MASK
	MOV	AH,BL
	SHL	AH,1				; EXPAND C0 TO C1, C2 TO C3
	OR	BL,AH				; BUILD ?(80H) + (0,3,C,F)
NO_ADJ1:
	SUB	AH,AH				; ZERO
	MUL	POINTS				; OFFSET FONT TABLE BASE
	PUSH	AX				; FONT TABLE DISPLACEMENT
	CALL	GR_CUR				; GET OFFSET INTO REGEN
	MOV	DI,AX				;  INTO DESTINATION
	MOV	BP,POINTS			; BYTES PER CHAR
	SRLOAD	ES,0A000H			; REGEN SEGEMNT
	LDS	SI,GRX_SET			; ADDRESSING TO FONTS
	POP	AX				; RECOVER OFFSET
	ADD	SI,AX				; CHARACTER IN TABLE
	MOV	DH,3
S20A:
	TEST	BL,080H				; TEST FOR XOR
	JZ	NO_XOR				; NO XOR
	MOV	DL,GRAPH_ADDR
	MOV	AX,0318H			; GRAPHICS CHIP XOR
	CALL	OUT_DX				; SET REGISTER
	JMP	F_2				; SKIP BLANK
NO_XOR:						; BLANK BOX FOR CHAR
	PUSH	DI				; SAVE REGEN POINTER
	MOV	DL,SEQ_ADDR
	MOV	AX,020FH			; ENABLE ALL MAPS
	CALL	OUT_DX
	SUB	AX,AX				; STORE ZERO
	PUSH	CX				; SAVE CHARACTER COUNT
	MOV	CX,BP				; GET BYTE COUNT
	PUSH	DS
	CALL	DDS
S13A:
	STOSB					; ZERO REGEN BYTE
	ADD	DI,CRT_COLS			; NEXT BYTE OF BOX
	DEC	DI				; ADJUST
	LOOP	S13A				; NEXT BYTE
	POP	DS
	POP	CX				; RECOVER CHARACTER COUNT
	POP	DI				; RECOVER REGEN POINTER
F_2:
	MOV	DL,SEQ_ADDR
	MOV	AH,02H				; SET MAP MASK
	MOV	AL,BL				;  FOR COLOR
	CALL	OUT_DX				; SET THE CHIP
	PUSH	DI				; SAVE OFFSET IN REGEN
	PUSH	BX				; SAVE COLOR VALUE
	PUSH	CX				; SAVE CHACTER COUNT
	MOV	BX,BP				; LOOP CONTROL, BYTES/CHAR
	PUSH	DS				; SAVE FONT SEGMENT
	CALL	DDS				; SET LOW RAM SEGMENT
	ASSUME	DS:ABS0
	MOV	CX,CRT_COLS			; GET COLUMN COUNT
	POP	DS				; RESTORE FONT SEGMENT
	ASSUME	DS:NOTHING
S1K:						; WRITE OUT THE CHARACTER
	MOV	AL,DS:[SI]			; CODE POINT
	MOV	AH,ES:[DI]			; LATCH DATA
	MOV	ES:[DI],AL			; WRITE ONE BYTE OF FONT
	INC	SI				; NEXT FONT POINT
	ADD	DI,CX				; ONE ROW BELOW LAST POINT
	DEC	BX				; BYTES PER CHAR COUNTER
	JNZ	S1K				; DO NEXT ROW OF CHARACTER

	POP	CX				; CHARACTER COUNT
	POP	BX				; COLOR VALUE
	SUB	SI,BP				; ADJUST PTR TO FONT TABLE
	POP	DI				; REGEN POINTER
	INC	DI				; NEXT CHAR POSN IN REGEN
	LOOP	S20A				; WRITE ANOTHER CHARACTER

	MOV	DL,GRAPH_ADDR
	MOV	AX,0300H			; NORMAL WRITE, NO ROTATE
	CALL	OUT_DX				; SET THE CHIP
	MOV	DL,SEQ_ADDR
	MOV	AX,020FH			; ENABLE ALL MAPS
	CALL	OUT_DX				; SET THE CHIP
	JMP	V_RET
GRX_WRT ENDP

	SUBTTL

