	SUBTTL	VSCROLL.INC
	PAGE

FLTA	PROC	NEAR				; CHECK FOR SCROLL COUNT
	PUSH	AX
	MOV	AH,DH				; LOWER ROW
	SUB	AH,CH				; UPPER ROW
	INC	AH				; NUMBER TO SCROLL
	CMP	AH,AL				; SAME AS REQUESTED
	POP	AX
	JNE	LTA
	SUB	AL,AL				; YES, SET TO 0 FOR BLANK
LTA:
	RET
FLTA	ENDP

CRANK	PROC	NEAR				; MOVE ROWS OF PELS UP
	PUSH	BX
	ASSUME	DS:ABS0
	PUSH	DS				; SAVE DATA SEGMENT
	CALL	DDS				; SET DATA SEGMENT
	MOV	BX,CRT_COLS
	POP	DS
CRANK_A:
	PUSH	CX				; SAVE MOVE COUNT
	MOV	CL,DL				; COLUMN COUNT
	SUB	CH,CH				; CLEAR HIGH BYTE
	PUSH	SI				; SAVE POINTERS
	PUSH	DI
	REP	MOVSB				; MOVE THAT ROW
	POP	DI				; RECOVER POINTERS
	POP	SI
	ADD	SI,BX				; NEXT ROW
	ADD	DI,BX				; NEXT ROW
	POP	CX				; RECOVER ROW COUNT
	LOOP	CRANK_A				; DO MORE
	POP	BX
	RET					; RETURN TO CALLER
CRANK	ENDP

CRANK_4 PROC	NEAR				; MOVE ROWS OF PELS DOWN
	PUSH	BX
	ASSUME	DS:ABS0
	PUSH	DS				; SAVE DATA SEGMENT
	CALL	DDS				; SET DATA SEGMENT
	MOV	BX,CRT_COLS
	POP	DS
CRANK_8:
	PUSH	CX				; SAVE MOVE COUNT
	MOV	CL,DL				; COLUMN COUNT
	SUB	CH,CH				; CLEAR HIGH BYTE
	PUSH	SI				; SAVE POINTERS
	PUSH	DI
	REP	MOVSB				; MOVE THAT ROW
	POP	DI				; RECOVER POINTERS
	POP	SI
	SUB	SI,BX				; NEXT ROW
	SUB	DI,BX				; NEXT ROW
	POP	CX				; RECOVER ROW COUNT
	LOOP	CRANK_8				; DO MORE
	POP	BX
	RET					; RETURN TO CALLER
CRANK_4 ENDP

PART_1	PROC	NEAR				; FILL ROW AFTER SCROLL
	PUSH	DX
	MOV	DH,3
	MOV	DL,SEQ_ADDR			; SEQUENCER
	MOV	AX,020FH			; MAP MASK
	CALL	OUT_DX				; ALL MAPS ON
	POP	DX
	SUB	AX,AX				; ZERO
	MOV	CL,DL				; COLUMN COUNT
	SUB	CH,CH
	PUSH	DI				; SAVE POINTER
	REP	STOSB				; CLEAR ONE ROW OF PELS
	POP	DI				; RECOVER POINTER
	MOV	AL,DH				; GET COLOR VALUE
	PUSH	DX
	MOV	DH,3
	MOV	DL,SEQ_ADDR			; SEQUENCER
	MOV	AH,02H				; MAP MASK
	CALL	OUT_DX				; SET THE COLOR
	POP	DX
	MOV	AL,0FFH				; ALL BITS ON
	MOV	CL,DL				; COLUMN COUNT
	PUSH	DI				; SAVE POINTER
	REP	STOSB				; TURN ON THOSE BITS IN
						;  ENABLED PLANES
	POP	DI				; RECOVER POINTER
	RET
PART_1	ENDP

PART_2	PROC	NEAR
	MOV	DH,3
	MOV	DL,SEQ_ADDR			; SEQUENCER
	MOV	AX,020FH			; MAP MASK, ALL MAPS
	CALL	OUT_DX				; ENABLE THE MAPS
	RET					; RETURN TO CALLER
PART_2	ENDP

BLNK_3	PROC	NEAR				; BLANK FOR SCROLL UP
	PUSH	DS				; SAVE DATA SEGMENT
	ASSUME	DS:ABS0
	CALL	DDS				; GET LOW MEMORY SEGMENT
	MOV	DH,BH				; ATTRIBUTE FOR BLANK LINE
	SUB	BH,BH				; CLEAR HIGH BYTE
	PUSH	AX				; SAVE
	PUSH	DX				; SAVE BECAUSE OF MULTIPLY
	MOV	AX,BX				; ROW COUNT
	MUL	POINTS				; CHARACTER HEIGHT
	MOV	BX,AX				; NET VALUE TO BX
	POP	DX				; RECOVER
	POP	AX

	POP	DS
	ASSUME	DS:NOTHING
S13:
	CALL	PART_1				; BLANK OUT ROW WITH COLOR
	ASSUME	DS:ABS0
	PUSH	DS				; SAVE SEGMENT
	CALL	DDS				; LOW MEMORY SEGMENT
	ADD	DI,CRT_COLS			; NEXT ROW
	POP	DS				; RECOVER
	DEC	BX				; NEXT
	JNZ	S13				; DO MORE
	CALL	PART_2
	RET					; RETURN TO CALLER
BLNK_3	ENDP

BLNK_4	PROC	NEAR				; BLANK FOR SCROLL DOWN
	PUSH	DS				; SAVE DATA SEGMENT
	ASSUME	DS:ABS0
	CALL	DDS				; GET LOW MEMORY SEGMENT
	MOV	DH,BH				; ATTRIBUTE FOR BLANK LINE
	SUB	BH,BH				; CLEAR HIGH BYTE
	PUSH	AX				; SAVE
	PUSH	DX				; SAVE BECAUSE OF MULTIPLY
	MOV	AX,BX				; ROW COUNT
	MUL	POINTS				; CHARACTER HEIGHT
	MOV	BX,AX				; NET VALUE TO BX
	POP	DX				; RECOVER
	POP	AX

	POP	DS
	ASSUME	DS:NOTHING
S13_4:
	CALL	PART_1				; BLANK OUT ROW WITH COLOR
	ASSUME	DS:ABS0
	PUSH	DS				; SAVE SEGMENT
	CALL	DDS				; LOW MEMORY SEGMENT
	SUB	DI,CRT_COLS			; NEXT ROW
	POP	DS				; RECOVER
	DEC	BX				; NEXT
	JNZ	S13_4				; DO MORE
	CALL	PART_2
	RET					; RETURN TO CALLER
BLNK_4	ENDP

;--------------------------------------------------------
; SCROLL UP						:
;	THIS ROUTINE MOVES A BLOCK OF CHARACTERS UP	:
;	ON THE SCREEN					:
; INPUT							:
;	(AH) = CURRENT CRT MODE				:
;	(AL) = NUMBER OF ROWS TO SCROLL			:
;	(CX) = ROW/COLUMN OF UPPER LEFT CORNER		:
;	(DX) = ROW/COLUMN OF LOWER RIGHT CORNER		:
;	(BH) = ATTRIBUTE TO BE USED ON BLANKED LINE	:
;	(DS) = DATA SEGMENT				:
;	(ES) = REGEN BUFFER SEGMENT			:
; OUTPUT						:
;	NONE -- THE REGEN BUFFER IS MODIFIED		:
;--------------------------------------------------------
	ASSUME	CS:CODE,DS:ABS0,ES:NOTHING
SCROLL_UP	PROC	NEAR
	MOV	BL,AL				; SAVE LINE COUNT IN BL
	CALL	MK_ES
	CMP	AH,4				; TEST FOR GRAPHICS MODE
	JB	N1				; HANDLE SEPERATELY
	CMP	AH,7				; TEST FOR BW CARD
	JE	N1
	JMP	GRAPHICS_UP
N1:						; UP_CONTINUE
	PUSH	BX				; SAVE FILL ATTR IN BH
	MOV	AX,CX				; UPPER LEFT POSITION
	CALL	SCROLL_POSITION			; DO SETUP FOR SCROLL
	JZ	N7				; BLANK_FIELD
	ADD	SI,AX				; FROM ADDRESS
	MOV	AH,DH				; # ROWS IN BLOCK
	SUB	AH,BL				; # ROWS TO BE MOVED
N2:						; ROW_LOOP
	CALL	N10				; MOVE ONE ROW
	ADD	SI,BP
	ADD	DI,BP				; NEXT LINE IN BLOCK
	DEC	AH				; COUNT OF LINES TO MOVE
	JNZ	N2				; ROW_LOOP
N3:						; CLEAR_ENTRY
	POP	AX				; RECOVER ATTRIBUTE IN AH
	MOV	AL,' '				; FILL WITH BLANKS
N4:						; CLEAR_LOOP
	CALL	N11				; CLEAR THE ROW
	ADD	DI,BP				; POINT TO THE NEXT LINE
	DEC	BL				; LINES TO SCROLL
	JNZ	N4				; SCROLL_END
N5:
	CALL	DDS
	CMP	CRT_MODE,7			; IS THIS THE B/W CARD
	JE	N6				; SKIP THE MODE RESET
	MOV	AL,CRT_MODE_SET			; GET THE MODE SET
	MOV	DX,03D8H			; ALWAYS SET COLOR CARD
	OUT	DX,AL
N6:						; VIDEO_RET_HERE
	JMP	V_RET
N7:						; BLANK_FIELD
	MOV	BL,DH				; GET ROW COUNT
	JMP	N3				; GO CLEAR THAT AREA
SCROLL_UP	ENDP

;----- HANDLE COMMON SCROLL SET UP HERE

SCROLL_POSITION PROC	NEAR
	TEST	INFO,4
	JZ	N9

;----- 80X25 COLOR CARD SCROLL

	PUSH	DX
	MOV	DH,3
	MOV	DL,0DAH				; COLOR CARD HERE
	PUSH	AX
N8:						; WAIT_DISP_ENABLE
	IN	AL,DX
	TEST	AL,8				; WAIT FOR VERT RETRACE
	JZ	N8				; WAIT_DISP_ENABLE
	MOV	AL,25H
	MOV	DL,0D8H				; DX=3D8
	OUT	DX,AL				; TURN OFF VIDEO
	POP	AX				;  DURING VERTICAL RETRACE
	POP	DX
N9:
	CALL	POSITION			; CONVERT TO REGEN POINTER
	ADD	AX,CRT_START			; OFFSET OF ACTIVE PAGE
	MOV	DI ,AX				; TO ADDRESS FOR SCROLL
	MOV	SI ,AX				; FROM ADDRESS FOR SCROLL
	SUB	DX,CX				; DX = #ROWS, #COLS
	INC	DH
	INC	DL				; INCREMENT FOR 0 ORIGIN
	XOR	CH,CH				; ZERO HIGH BYTE OF COUNT
	MOV	BP,CRT_COLS			; NUM OF COLS IN DISPLAY
	ADD	BP,BP				; TIMES 2 FOR ATTR BYTE
	MOV	AL,BL				; GET LINE COUNT
	MUL	BYTE PTR CRT_COLS		; OFFSET TO FROM ADDRESS
	ADD	AX,AX				; *2 FOR ATTRIBUTE BYTE
	PUSH	ES				; ESTABLISH ADDRESSING
	POP	DS				; FOR BOTH POINTERS
	CMP	BL,0				; 0 MEANS BLANK FIELD
	RET					; RETURN WITH FLAGS SET
SCROLL_POSITION ENDP

;----- MOVE_ROW

N10	PROC	NEAR
	MOV	CL,DL				; GET # OF COLS TO MOVE
	PUSH	SI
	PUSH	DI				; SAVE START ADDRESS
	REP	MOVSW				; MOVE THAT LINE ON SCREEN
	POP	DI
	POP	SI				; RECOVER ADDRESSES
	RET
N10	ENDP

;----- CLEAR_ROW

N11	PROC	NEAR
	MOV	CL,DL				; GET # COLUMNS TO CLEAR
	PUSH	DI
	REP	STOSW				; STORE THE FILL CHARACTER
	POP	DI
	RET
N11	ENDP

;--------------------------------------------------------
; SCROLL_DOWN						:
;	THIS ROUTINE MOVES THE CHARACTERS WITHIN A	:
;	DEFINED BLOCK DOWN ON THE SCREEN, FILLING THE	:
;	TOP LINES WITH A DEFINED CHARACTER		:
; INPUT							:
;	(AH) = CURRENT CRT MODE				:
;	(AL) = NUMBER OF LINES TO SCROLL		:
;	(CX) = UPPER LEFT CORNER OF REGION		:
;	(DX) = LOWER RIGHT CORNER OF REGION		:
;	(BH) FILL CHARACTER				:
;	(DS) DATA SEGMENT				:
;	(ES) REGEN SEGMENT				:
; OUTPUT						:
;	NONE -- SCREEN IS SCROLLED			:
;--------------------------------------------------------
SCROLL_DOWN	PROC	NEAR
	STD					; SCROLL DOWN
	MOV	BL,AL				; LINE COUNT TO BL
	CALL	MK_ES
	PUSH	BX				; SAVE ATTRIBUTE IN BH
	MOV	AX,DX				; LOWER RIGHT CORNER
	CALL	SCROLL_POSITION			; GET REGEN LOCATION
	JZ	N16
	SUB	SI,AX				; SI IS FROM ADDRESS
	MOV	AH,DH				; GET TOTAL # ROWS
	SUB	AH,BL				; COUNT TO MOVE IN SCROLL
N13:
	CALL	N10				; MOVE ONE ROW
	SUB	SI,BP
	SUB	DI,BP
	DEC	AH
	JNZ	N13
N14:
	POP	AX				; RECOVER ATTRIBUTE IN AH
	MOV	AL,' '
N15:
	CALL	N11				; CLEAR ONE ROW
	SUB	DI,BP				; GO TO NEXT ROW
	DEC	BL
	JNZ	N15
	JMP	N5				; SCROLL_END
N16:
	MOV	BL,DH
	JMP	N14
SCROLL_DOWN	ENDP

;----------------------------------------------------------------
; SCROLL_UP							:
;	THIS ROUTINE SCROLLS UP THE INFORMATION ON THE CRT	:
; ENTRY								:
;	CH,CL = UPPER LEFT CORNER OF REGION TO SCROLL		:
;	DH,DL = LOWER RIGHT CORNER OF REGION TO SCROLL		:
;	 BOTH OF THE ABOVE ARE IN CHARACTER POSITIONS		:
;	BH = FILL VALUE FOR BLANKED LINES			:
;	AL = # LINES TO SCROLL (AL=0 MEANS BLANK THE ENTIRE	:
;	     FIELD)						:
;	DS = DATA SEGMENT					:
;	ES = REGEN SEGMENT					:
; EXIT								:
;	NOTHING, THE SCREEN IS SCROLLED				:
;----------------------------------------------------------------
GRAPHICS_UP	PROC	NEAR
	MOV	BL,AL				; SAVE LINE COUNT IN BL
	MOV	AX,CX				; GET UPPER LEFT POSITION
						;  INTO AX REG

;----- USE CHARACTER SUBROUTINE FOR POSITIONING
;----- ADDRESS RETURNED IS MULTIPLIED BY 2 FROM CORRECT VALUE

	CALL	GRAPH_POSN
	MOV	DI,AX				; SAVE RESULT AS
						;  DESTINATION ADDRESS

;----- DETERMINE SIZE OF WINDOW

	SUB	DX,CX
	ADD	DX,101H				; ADJUST VALUES
	SAL	DH,1				; MULTIPLY # ROWS BY 4
						; SINCE 8 VERT DOTS/CHAR
	SAL	DH,1				; AND EVEN/ODD ROWS

;----- DETERMINE CRT MODE

	CMP	CRT_MODE,6			; TEST FOR MEDIUM RES
	JNC	R7				; FIND_SOURCE

;----- MEDIUM RES UP

	SAL	DL,1				; * 2
	SAL	DI,1				;  SINCE 2 BYTES/CHAR

;----- DETERMINE THE SOURCE ADDRESS IN THE BUFFER

R7:						; FIND_SOURCE
	PUSH	ES				; GET SEGMENTS BOTH
	POP	DS				;  POINTING TO REGEN
	SUB	CH,CH				; 0 TO HIGH OF COUNT REG
	SAL	BL,1				; NUMBER OF LINES *4
	SAL	BL,1
	JZ	R11				; IF 0, BLANK ENTIRE FIELD
	MOV	AL,BL				; NUMBER OF LINES IN AL
	MOV	AH,80				; 80 BYTES/ROW
	MUL	AH				; OFFSET TO SOURCE
	MOV	SI,DI				; SET UP SOURCE
	ADD	SI,AX				;  ADD IN OFFSET TO IT
	MOV	AH,DH				; NUMBER OF ROWS IN FIELD
	SUB	AH,BL				; DETERMINE NUMBER TO MOVE

;---- LOOP THROUGH, MOVING ONE ROW AT A TIME, BOTH EVEN AND ODD FIELDS

R8:						; ROW_LOOP
	CALL	R17				; MOVE ONE ROW
	SUB	SI,2000H-80			; MOVE TO NEXT ROW
	SUB	DI,2000H-80
	DEC	AH				; NUMBER OF ROWS TO MOVE
	JNZ	R8				; CONTINUE TILL ALL MOVED

;----- FILL IN THE VACATED LINE(S)

R9:						; CLEAR_ENTRY
	MOV	AL,BH				; ATTRIBUTE TO FILL WITH
R10:
	CALL	R18				; CLEAR THAT ROW
	SUB	DI,2000H-80			; POINT TO NEXT LINE
	DEC	BL				; NUMBER OF LINES TO FILL
	JNZ	R10				; CLEAR_LOOP
	JMP	V_RET
R11:						; BLANK_FIELD
	MOV	BL,DH				; SET BLANK COUNT TO
						;  EVERYTHING IN FIELD
	JMP	R9				; CLEAR THE FIELD
GRAPHICS_UP	ENDP

;----- ROUTINE TO MOVE ONE ROW OF INFORMATION

R17	PROC	NEAR
	MOV	CL,DL				; NUM OF BYTES IN THE ROW
	PUSH	SI
	PUSH	DI				; SAVE POINTERS
	REP	MOVSB				; MOVE THE EVEN FIELD
	POP	DI
	POP	SI
	ADD	SI,2000H
	ADD	DI,2000H			; POINT TO THE ODD FIELD
	PUSH	SI
	PUSH	DI				; SAVE THE POINTERS
	MOV	CL,DL				; COUNT BACK
	REP	MOVSB				; MOVE THE ODD FIELD
	POP	DI
	POP	SI				; POINTERS BACK
	RET					; RETURN TO CALLER
R17	ENDP

;----- CLEAR A SINGLE ROW

R18	PROC	NEAR
	MOV	CL,DL				; NUMBER OF BYTES IN FIELD
	PUSH	DI				; SAVE POINTER
	REP	STOSB				; STORE THE NEW VALUE
	POP	DI				; POINTER BACK
	ADD	DI,2000H			; POINT TO ODD FIELD
	PUSH	DI
	MOV	CL,DL
	REP	STOSB				; FILL THE ODD FIELD
	POP	DI
	RET					; RETURN TO CALLER
R18	ENDP

MEM_DET PROC	NEAR
	ASSUME	DS:ABS0
	PUSH	AX
	PUSH	DS
	CALL	DDS
	MOV	AH,INFO
	AND	AH,060H
	POP	DS
	POP	AX
	JZ	MIN
	STC
	RET
MIN:
	CLC
	RET
MEM_DET ENDP

;----- SCROLL ACTIVE PAGE UP

SC_2:
	JMP	SCROLL_UP

AH6:
	ASSUME	DS:ABS0
	CALL	FLTA
	MOV	AH,CRT_MODE			; GET CURRENT MODE
	CMP	AH,07H
	JBE	SC_2				; ANY OF THE OLD MODES
	CMP	AH,0DH
	JAE	GRAPHICS_UP_2			; NEW GRAPHICS MODES
	JMP	V_RET				; NOT A RECOGNIZED MODE

GR_ST_1 PROC	NEAR
	MOV	DX,0A000H			; REGEN BUFFER
	MOV	BP,0511H			; GRAPHICS WRITE MODE
	CMP	AH,0FH
	JB	VV1
	CALL	MEM_DET
	JNC	VV1
	MOV	BP,0501H			; GRAPHICS WRITE MODE
VV1:
	RET
GR_ST_1 ENDP

GRAPHICS_UP_2	PROC	NEAR
	ASSUME	DS:ABS0
	PUSH	DX
	CALL	GR_ST_1				; SET SEGMENT, WRITE MODE
	SRLOAD	ES				; SET REGEN
	POP	DX
	MOV	BL,AL				; NUMBER OF LINES
	MOV	AX,CX				; UPPER LEFT CORNER
	PUSH	BX
	MOV	BH,ACTIVE_PAGE			; ACTIVE PAGE FOR SCROLL
	CALL	GRX_PSN				; ADDRESS IN REGEN
	POP	BX
	MOV	DI,AX				; SEG POINTER
	SUB	DX,CX				; DETERMINE WINDOW
	ADD	DX,0101H			; ADJUST
	SUB	AH,AH				; ZERO HIGH BYTE
	MOV	AL,BL				; LINE COUNT
	PUSH	DX
	MUL	POINTS				; BYTES PER CHARACTER
	MUL	CRT_COLS			; COLUMNS
	MOV	SI,DI				; SET UP SOURCE INDEX
	ADD	SI,AX				; ADJUST
	ASSUME	DS:NOTHING
	PUSH	ES
	POP	DS
	POP	DX
	OR	BL,BL				; LINE COUNT
	JZ	AR9
	MOV	CL,DH
	SUB	CL,BL
	SUB	CH,CH

	ASSUME	DS:ABS0
	PUSH	DS
	CALL	DDS				; LOW MEMORY SEGMENT
	PUSH	AX
	PUSH	DX
	MOV	AX,CX
	MUL	POINTS				; BYTES PER CHAR
	MOV	CX,AX				; SET THE COUNT
	POP	DX
	POP	AX
	ASSUME	DS:NOTHING
	POP	DS

	PUSH	DX
	MOV	AX,BP
	MOV	DH,3
	MOV	DL,GRAPH_ADDR			; GRAPHICS
	CALL	OUT_DX
	MOV	DL,SEQ_ADDR			; SEQUENCER
	MOV	AX,020FH			; ENABLE ALL MAPS
	CALL	OUT_DX
	POP	DX
	CALL	CRANK				; SCROLL THE SCREEN

	PUSH	DX
	DEC	BP
	MOV	AX,BP
	MOV	DH,3
	MOV	DL,GRAPH_ADDR
	CALL	OUT_DX
	POP	DX
AR10:
	CALL	BLNK_3
	JMP	V_RET
AR9:
	MOV	BL,DH				; BLANK ENTIRE WINDOW
	JMP	AR10
GRAPHICS_UP_2	ENDP

;----- SCROLL ACTIVE DISPLAY PAGE DOWN

SC_3:
	JMP	SCROLL_DOWN

AH7:
	ASSUME	DS:ABS0
	CALL	FLTA
	MOV	AH,CRT_MODE
	CMP	AH,03H				; OLD COLOR ALPHA
	JBE	SC_3
	CMP	AH,07H				; MONOCHROME ALPHA
	JE	SC_3

	CMP	AH,0DH				; NEW GRAPHICS MODES
	JAE	GRAPHICS_DN_2
	CMP	AH,06H				; OLD GRAPHICS MODES
	JA	M_O
	MOV	AH,07H
	INT	42H
M_O:
	JMP	V_RET

GRAPHICS_DN_2	PROC	NEAR
	STD					; DIRECTION TO DECREMENT
	MOV	BL,AL				; LINE COUNT
	PUSH	DX				; SAVE LOWER RIGHT
	CALL	GR_ST_1				; SET REGEN SEGMENT
	SRLOAD	ES
	POP	DX
	MOV	AX,DX
	INC	AH				; MOV CHAR ROW UP BY ONE
	PUSH	BX
	MOV	BH,ACTIVE_PAGE
	CALL	GRX_PSN				; ADDRESS IN REGEN
	POP	BX
	SUB	AX,CRT_COLS			; ONE SCAN OVERSHOOT
	MOV	DI,AX
	SUB	DX,CX				; CALCULATE WINDOW
	ADD	DX,0101H			; ADJUST COUNT
	SUB	AH,AH
	MOV	AL,BL
	PUSH	DX
	MUL	POINTS				; BYTES PER CHAR
	MUL	CRT_COLS			; BYTES PER ROW
	MOV	SI,DI
	SUB	SI,AX
	ASSUME	DS:NOTHING
	PUSH	ES				; SET DS TO
	POP	DS				;  THE REGEN SEGMENT
	POP	DX
	OR	BL,BL				; SCROLL COUNT
	JZ	DXR9				; BLANK ENTIRE WINDOW
	MOV	CL,DH
	SUB	CL,BL
	SUB	CH,CH

	ASSUME	DS:ABS0
	PUSH	DS
	CALL	DDS
	PUSH	AX
	PUSH	DX
	MOV	AX,CX
	MUL	POINTS				; BYTES PER CHAR
	MOV	CX,AX
	POP	DX
	POP	AX
	ASSUME	DS:NOTHING
	POP	DS

	PUSH	DX
	MOV	AX,BP
	MOV	DH,3
	MOV	DL,GRAPH_ADDR			; GRAPHICS
	CALL	OUT_DX
	MOV	DL,SEQ_ADDR			; SEQUENCER
	MOV	AX,020FH			; ENABLE ALL MAPS
	CALL	OUT_DX
	POP	DX
	CALL	CRANK_4				; SCROLL THE SCREEN

	PUSH	DX
	DEC	BP
	MOV	AX,BP
	MOV	DH,3
	MOV	DL,GRAPH_ADDR
	CALL	OUT_DX
	POP	DX
DXR10:
	CALL	BLNK_4
	CLD
	JMP	V_RET
DXR9:
	MOV	BL,DH				; BLANK ENTIRE WINDOW
	JMP	DXR10
GRAPHICS_DN_2	ENDP

	SUBTTL

